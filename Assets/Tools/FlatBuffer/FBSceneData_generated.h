// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_FBSCENEDATA_FBSCENEDATA_H_
#define FLATBUFFERS_GENERATED_FBSCENEDATA_FBSCENEDATA_H_

#include "flatbuffers/flatbuffers.h"


namespace FBSceneData {

struct Vector2;
struct Vector3;
struct Quaternion;
struct Color;
struct DEntityInfo;
struct FunctionPrefab;
struct DNPCInfo;
struct DMonsterInfo;
struct DTransferInfo;
struct DDecoratorInfo;
struct DDestructibleInfo;
struct DRegionInfo;
struct DTransportDoor;
struct DTownDoor;
struct DSceneData;

enum DEntityType {
  DEntityType_NPC = 0,
  DEntityType_MONSTER = 1,
  DEntityType_DECORATOR = 2,
  DEntityType_DESTRUCTIBLE = 3,
  DEntityType_REGION = 4,
  DEntityType_TRANSPORTDOOR = 5,
  DEntityType_BOSS = 6,
  DEntityType_ELITE = 7,
  DEntityType_BIRTHPOSITION = 8,
  DEntityType_TOWNDOOR = 9,
  DEntityType_FUNCTION_PREFAB = 10,
  DEntityType_MONSTERDESTRUCT = 11,
  DEntityType_HELLBIRTHPOSITION = 12,
  DEntityType_MAX = 13
};

inline const char **EnumNamesDEntityType() {
  static const char *names[] = { "NPC", "MONSTER", "DECORATOR", "DESTRUCTIBLE", "REGION", "TRANSPORTDOOR", "BOSS", "ELITE", "BIRTHPOSITION", "TOWNDOOR", "FUNCTION_PREFAB", "MONSTERDESTRUCT", "HELLBIRTHPOSITION", "MAX", nullptr };
  return names;
}

inline const char *EnumNameDEntityType(DEntityType e) { return EnumNamesDEntityType()[e]; }

enum FunctionType {
  FunctionType_FT_FollowPet = 0,
  FunctionType_FT_FollowPet2 = 1,
  FunctionType_FT_COUNT = 2
};

inline const char **EnumNamesFunctionType() {
  static const char *names[] = { "FT_FollowPet", "FT_FollowPet2", "FT_COUNT", nullptr };
  return names;
}

inline const char *EnumNameFunctionType(FunctionType e) { return EnumNamesFunctionType()[e]; }

enum MonsterSwapType {
  MonsterSwapType_POINT_SWAP = 0,
  MonsterSwapType_CIRCLE_SWAP = 1,
  MonsterSwapType_RECT_SWAP = 2
};

inline const char **EnumNamesMonsterSwapType() {
  static const char *names[] = { "POINT_SWAP", "CIRCLE_SWAP", "RECT_SWAP", nullptr };
  return names;
}

inline const char *EnumNameMonsterSwapType(MonsterSwapType e) { return EnumNamesMonsterSwapType()[e]; }

enum FaceType {
  FaceType_Right = 0,
  FaceType_Left = 1,
  FaceType_Random = 2
};

inline const char **EnumNamesFaceType() {
  static const char *names[] = { "Right", "Left", "Random", nullptr };
  return names;
}

inline const char *EnumNameFaceType(FaceType e) { return EnumNamesFaceType()[e]; }

enum FlowRegionType {
  FlowRegionType_None = 0,
  FlowRegionType_Region = 1,
  FlowRegionType_Destruct = 2
};

inline const char **EnumNamesFlowRegionType() {
  static const char *names[] = { "None", "Region", "Destruct", nullptr };
  return names;
}

inline const char *EnumNameFlowRegionType(FlowRegionType e) { return EnumNamesFlowRegionType()[e]; }

enum RegionType {
  RegionType_Circle = 0,
  RegionType_Rectangle = 1
};

inline const char **EnumNamesRegionType() {
  static const char *names[] = { "Circle", "Rectangle", nullptr };
  return names;
}

inline const char *EnumNameRegionType(RegionType e) { return EnumNamesRegionType()[e]; }

enum TransportDoorType {
  TransportDoorType_Left = 0,
  TransportDoorType_Top = 1,
  TransportDoorType_Right = 2,
  TransportDoorType_Buttom = 3,
  TransportDoorType_None = 4
};

inline const char **EnumNamesTransportDoorType() {
  static const char *names[] = { "Left", "Top", "Right", "Buttom", "None", nullptr };
  return names;
}

inline const char *EnumNameTransportDoorType(TransportDoorType e) { return EnumNamesTransportDoorType()[e]; }

enum DoorTargetType {
  DoorTargetType_Normal = 0,
  DoorTargetType_PVEPracticeCourt = 1
};

inline const char **EnumNamesDoorTargetType() {
  static const char *names[] = { "Normal", "PVEPracticeCourt", nullptr };
  return names;
}

inline const char *EnumNameDoorTargetType(DoorTargetType e) { return EnumNamesDoorTargetType()[e]; }

enum EWeatherMode {
  EWeatherMode_None = 0,
  EWeatherMode_Rain = 1,
  EWeatherMode_Wind = 2,
  EWeatherMode_Snow = 3,
  EWeatherMode_MaxModeNum = 4
};

inline const char **EnumNamesEWeatherMode() {
  static const char *names[] = { "None", "Rain", "Wind", "Snow", "MaxModeNum", nullptr };
  return names;
}

inline const char *EnumNameEWeatherMode(EWeatherMode e) { return EnumNamesEWeatherMode()[e]; }

MANUALLY_ALIGNED_STRUCT(4) Vector2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vector2(float x, float y)
    : x_(flatbuffers::EndianScalar(x)), y_(flatbuffers::EndianScalar(y)) { }

  float x() const { return flatbuffers::EndianScalar(x_); }
  float y() const { return flatbuffers::EndianScalar(y_); }
};
STRUCT_END(Vector2, 8);

MANUALLY_ALIGNED_STRUCT(4) Vector3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vector3(float x, float y, float z)
    : x_(flatbuffers::EndianScalar(x)), y_(flatbuffers::EndianScalar(y)), z_(flatbuffers::EndianScalar(z)) { }

  float x() const { return flatbuffers::EndianScalar(x_); }
  float y() const { return flatbuffers::EndianScalar(y_); }
  float z() const { return flatbuffers::EndianScalar(z_); }
};
STRUCT_END(Vector3, 12);

MANUALLY_ALIGNED_STRUCT(4) Quaternion FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Quaternion(float x, float y, float z, float w)
    : x_(flatbuffers::EndianScalar(x)), y_(flatbuffers::EndianScalar(y)), z_(flatbuffers::EndianScalar(z)), w_(flatbuffers::EndianScalar(w)) { }

  float x() const { return flatbuffers::EndianScalar(x_); }
  float y() const { return flatbuffers::EndianScalar(y_); }
  float z() const { return flatbuffers::EndianScalar(z_); }
  float w() const { return flatbuffers::EndianScalar(w_); }
};
STRUCT_END(Quaternion, 16);

MANUALLY_ALIGNED_STRUCT(4) Color FLATBUFFERS_FINAL_CLASS {
 private:
  float r_;
  float g_;
  float b_;
  float a_;

 public:
  Color(float r, float g, float b, float a)
    : r_(flatbuffers::EndianScalar(r)), g_(flatbuffers::EndianScalar(g)), b_(flatbuffers::EndianScalar(b)), a_(flatbuffers::EndianScalar(a)) { }

  float r() const { return flatbuffers::EndianScalar(r_); }
  float g() const { return flatbuffers::EndianScalar(g_); }
  float b() const { return flatbuffers::EndianScalar(b_); }
  float a() const { return flatbuffers::EndianScalar(a_); }
};
STRUCT_END(Color, 16);

struct DEntityInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  int32_t globalid() const { return GetField<int32_t>(4, 0); }
  int32_t resid() const { return GetField<int32_t>(6, 0); }
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(8); }
  const flatbuffers::String *path() const { return GetPointer<const flatbuffers::String *>(10); }
  const flatbuffers::String *description() const { return GetPointer<const flatbuffers::String *>(12); }
  DEntityType type() const { return static_cast<DEntityType>(GetField<int8_t>(14, 0)); }
  const flatbuffers::String *type_name() const { return GetPointer<const flatbuffers::String *>(16); }
  const Vector3 *position() const { return GetStruct<const Vector3 *>(18); }
  float scale() const { return GetField<float>(20, 1.0); }
  const Color *color() const { return GetStruct<const Color *>(22); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4 /* globalid */) &&
           VerifyField<int32_t>(verifier, 6 /* resid */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* path */) &&
           verifier.Verify(path()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 12 /* description */) &&
           verifier.Verify(description()) &&
           VerifyField<int8_t>(verifier, 14 /* type */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 16 /* type_name */) &&
           verifier.Verify(type_name()) &&
           VerifyField<Vector3>(verifier, 18 /* position */) &&
           VerifyField<float>(verifier, 20 /* scale */) &&
           VerifyField<Color>(verifier, 22 /* color */) &&
           verifier.EndTable();
  }
};

struct DEntityInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_globalid(int32_t globalid) { fbb_.AddElement<int32_t>(4, globalid, 0); }
  void add_resid(int32_t resid) { fbb_.AddElement<int32_t>(6, resid, 0); }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(8, name); }
  void add_path(flatbuffers::Offset<flatbuffers::String> path) { fbb_.AddOffset(10, path); }
  void add_description(flatbuffers::Offset<flatbuffers::String> description) { fbb_.AddOffset(12, description); }
  void add_type(DEntityType type) { fbb_.AddElement<int8_t>(14, static_cast<int8_t>(type), 0); }
  void add_type_name(flatbuffers::Offset<flatbuffers::String> type_name) { fbb_.AddOffset(16, type_name); }
  void add_position(const Vector3 *position) { fbb_.AddStruct(18, position); }
  void add_scale(float scale) { fbb_.AddElement<float>(20, scale, 1.0); }
  void add_color(const Color *color) { fbb_.AddStruct(22, color); }
  DEntityInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DEntityInfoBuilder &operator=(const DEntityInfoBuilder &);
  flatbuffers::Offset<DEntityInfo> Finish() {
    auto o = flatbuffers::Offset<DEntityInfo>(fbb_.EndTable(start_, 10));
    return o;
  }
};

inline flatbuffers::Offset<DEntityInfo> CreateDEntityInfo(flatbuffers::FlatBufferBuilder &_fbb,
   int32_t globalid = 0,
   int32_t resid = 0,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   flatbuffers::Offset<flatbuffers::String> path = 0,
   flatbuffers::Offset<flatbuffers::String> description = 0,
   DEntityType type = DEntityType_NPC,
   flatbuffers::Offset<flatbuffers::String> type_name = 0,
   const Vector3 *position = 0,
   float scale = 1.0,
   const Color *color = 0) {
  DEntityInfoBuilder builder_(_fbb);
  builder_.add_color(color);
  builder_.add_scale(scale);
  builder_.add_position(position);
  builder_.add_type_name(type_name);
  builder_.add_description(description);
  builder_.add_path(path);
  builder_.add_name(name);
  builder_.add_resid(resid);
  builder_.add_globalid(globalid);
  builder_.add_type(type);
  return builder_.Finish();
}

struct FunctionPrefab FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const DEntityInfo *super() const { return GetPointer<const DEntityInfo *>(4); }
  FunctionType eFunctionType() const { return static_cast<FunctionType>(GetField<int8_t>(6, 0)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* super */) &&
           verifier.VerifyTable(super()) &&
           VerifyField<int8_t>(verifier, 6 /* eFunctionType */) &&
           verifier.EndTable();
  }
};

struct FunctionPrefabBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_super(flatbuffers::Offset<DEntityInfo> super) { fbb_.AddOffset(4, super); }
  void add_eFunctionType(FunctionType eFunctionType) { fbb_.AddElement<int8_t>(6, static_cast<int8_t>(eFunctionType), 0); }
  FunctionPrefabBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  FunctionPrefabBuilder &operator=(const FunctionPrefabBuilder &);
  flatbuffers::Offset<FunctionPrefab> Finish() {
    auto o = flatbuffers::Offset<FunctionPrefab>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<FunctionPrefab> CreateFunctionPrefab(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<DEntityInfo> super = 0,
   FunctionType eFunctionType = FunctionType_FT_FollowPet) {
  FunctionPrefabBuilder builder_(_fbb);
  builder_.add_super(super);
  builder_.add_eFunctionType(eFunctionType);
  return builder_.Finish();
}

struct DNPCInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const DEntityInfo *super() const { return GetPointer<const DEntityInfo *>(4); }
  const Quaternion *rotation() const { return GetStruct<const Quaternion *>(6); }
  const Vector2 *minFindRange() const { return GetStruct<const Vector2 *>(8); }
  const Vector2 *maxFindRange() const { return GetStruct<const Vector2 *>(10); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* super */) &&
           verifier.VerifyTable(super()) &&
           VerifyField<Quaternion>(verifier, 6 /* rotation */) &&
           VerifyField<Vector2>(verifier, 8 /* minFindRange */) &&
           VerifyField<Vector2>(verifier, 10 /* maxFindRange */) &&
           verifier.EndTable();
  }
};

struct DNPCInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_super(flatbuffers::Offset<DEntityInfo> super) { fbb_.AddOffset(4, super); }
  void add_rotation(const Quaternion *rotation) { fbb_.AddStruct(6, rotation); }
  void add_minFindRange(const Vector2 *minFindRange) { fbb_.AddStruct(8, minFindRange); }
  void add_maxFindRange(const Vector2 *maxFindRange) { fbb_.AddStruct(10, maxFindRange); }
  DNPCInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DNPCInfoBuilder &operator=(const DNPCInfoBuilder &);
  flatbuffers::Offset<DNPCInfo> Finish() {
    auto o = flatbuffers::Offset<DNPCInfo>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<DNPCInfo> CreateDNPCInfo(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<DEntityInfo> super = 0,
   const Quaternion *rotation = 0,
   const Vector2 *minFindRange = 0,
   const Vector2 *maxFindRange = 0) {
  DNPCInfoBuilder builder_(_fbb);
  builder_.add_maxFindRange(maxFindRange);
  builder_.add_minFindRange(minFindRange);
  builder_.add_rotation(rotation);
  builder_.add_super(super);
  return builder_.Finish();
}

struct DMonsterInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const DEntityInfo *super() const { return GetPointer<const DEntityInfo *>(4); }
  MonsterSwapType swapType() const { return static_cast<MonsterSwapType>(GetField<int8_t>(6, 0)); }
  uint8_t isFaceLeft() const { return GetField<uint8_t>(8, 0); }
  int32_t swapNum() const { return GetField<int32_t>(10, 0); }
  int32_t swapDelay() const { return GetField<int32_t>(12, 0); }
  int32_t flushGroupID() const { return GetField<int32_t>(14, 0); }
  int32_t subGroupID() const { return GetField<int32_t>(16, 0); }
  int32_t monsterInfoTableID() const { return GetField<int32_t>(18, 0); }
  FlowRegionType flowRegionType() const { return static_cast<FlowRegionType>(GetField<int8_t>(20, 0)); }
  const DRegionInfo *regionInfo() const { return GetPointer<const DRegionInfo *>(22); }
  const DDestructibleInfo *destructInfo() const { return GetPointer<const DDestructibleInfo *>(24); }
  int32_t sight() const { return GetField<int32_t>(26, 0); }
  int32_t groupIndex() const { return GetField<int32_t>(28, 0); }
  const flatbuffers::String *aiActionPath() const { return GetPointer<const flatbuffers::String *>(30); }
  const flatbuffers::String *aiScenarioPath() const { return GetPointer<const flatbuffers::String *>(32); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* super */) &&
           verifier.VerifyTable(super()) &&
           VerifyField<int8_t>(verifier, 6 /* swapType */) &&
           VerifyField<uint8_t>(verifier, 8 /* isFaceLeft */) &&
           VerifyField<int32_t>(verifier, 10 /* swapNum */) &&
           VerifyField<int32_t>(verifier, 12 /* swapDelay */) &&
           VerifyField<int32_t>(verifier, 14 /* flushGroupID */) &&
           VerifyField<int32_t>(verifier, 16 /* subGroupID */) &&
           VerifyField<int32_t>(verifier, 18 /* monsterInfoTableID */) &&
           VerifyField<int8_t>(verifier, 20 /* flowRegionType */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 22 /* regionInfo */) &&
           verifier.VerifyTable(regionInfo()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 24 /* destructInfo */) &&
           verifier.VerifyTable(destructInfo()) &&
           VerifyField<int32_t>(verifier, 26 /* sight */) &&
           VerifyField<int32_t>(verifier, 28 /* groupIndex */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 30 /* aiActionPath */) &&
           verifier.Verify(aiActionPath()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 32 /* aiScenarioPath */) &&
           verifier.Verify(aiScenarioPath()) &&
           verifier.EndTable();
  }
};

struct DMonsterInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_super(flatbuffers::Offset<DEntityInfo> super) { fbb_.AddOffset(4, super); }
  void add_swapType(MonsterSwapType swapType) { fbb_.AddElement<int8_t>(6, static_cast<int8_t>(swapType), 0); }
  void add_isFaceLeft(uint8_t isFaceLeft) { fbb_.AddElement<uint8_t>(8, isFaceLeft, 0); }
  void add_swapNum(int32_t swapNum) { fbb_.AddElement<int32_t>(10, swapNum, 0); }
  void add_swapDelay(int32_t swapDelay) { fbb_.AddElement<int32_t>(12, swapDelay, 0); }
  void add_flushGroupID(int32_t flushGroupID) { fbb_.AddElement<int32_t>(14, flushGroupID, 0); }
  void add_subGroupID(int32_t subGroupID) { fbb_.AddElement<int32_t>(16, subGroupID, 0); }
  void add_monsterInfoTableID(int32_t monsterInfoTableID) { fbb_.AddElement<int32_t>(18, monsterInfoTableID, 0); }
  void add_flowRegionType(FlowRegionType flowRegionType) { fbb_.AddElement<int8_t>(20, static_cast<int8_t>(flowRegionType), 0); }
  void add_regionInfo(flatbuffers::Offset<DRegionInfo> regionInfo) { fbb_.AddOffset(22, regionInfo); }
  void add_destructInfo(flatbuffers::Offset<DDestructibleInfo> destructInfo) { fbb_.AddOffset(24, destructInfo); }
  void add_sight(int32_t sight) { fbb_.AddElement<int32_t>(26, sight, 0); }
  void add_groupIndex(int32_t groupIndex) { fbb_.AddElement<int32_t>(28, groupIndex, 0); }
  void add_aiActionPath(flatbuffers::Offset<flatbuffers::String> aiActionPath) { fbb_.AddOffset(30, aiActionPath); }
  void add_aiScenarioPath(flatbuffers::Offset<flatbuffers::String> aiScenarioPath) { fbb_.AddOffset(32, aiScenarioPath); }
  DMonsterInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DMonsterInfoBuilder &operator=(const DMonsterInfoBuilder &);
  flatbuffers::Offset<DMonsterInfo> Finish() {
    auto o = flatbuffers::Offset<DMonsterInfo>(fbb_.EndTable(start_, 15));
    return o;
  }
};

inline flatbuffers::Offset<DMonsterInfo> CreateDMonsterInfo(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<DEntityInfo> super = 0,
   MonsterSwapType swapType = MonsterSwapType_POINT_SWAP,
   uint8_t isFaceLeft = 0,
   int32_t swapNum = 0,
   int32_t swapDelay = 0,
   int32_t flushGroupID = 0,
   int32_t subGroupID = 0,
   int32_t monsterInfoTableID = 0,
   FlowRegionType flowRegionType = FlowRegionType_None,
   flatbuffers::Offset<DRegionInfo> regionInfo = 0,
   flatbuffers::Offset<DDestructibleInfo> destructInfo = 0,
   int32_t sight = 0,
   int32_t groupIndex = 0,
   flatbuffers::Offset<flatbuffers::String> aiActionPath = 0,
   flatbuffers::Offset<flatbuffers::String> aiScenarioPath = 0) {
  DMonsterInfoBuilder builder_(_fbb);
  builder_.add_aiScenarioPath(aiScenarioPath);
  builder_.add_aiActionPath(aiActionPath);
  builder_.add_groupIndex(groupIndex);
  builder_.add_sight(sight);
  builder_.add_destructInfo(destructInfo);
  builder_.add_regionInfo(regionInfo);
  builder_.add_monsterInfoTableID(monsterInfoTableID);
  builder_.add_subGroupID(subGroupID);
  builder_.add_flushGroupID(flushGroupID);
  builder_.add_swapDelay(swapDelay);
  builder_.add_swapNum(swapNum);
  builder_.add_super(super);
  builder_.add_flowRegionType(flowRegionType);
  builder_.add_isFaceLeft(isFaceLeft);
  builder_.add_swapType(swapType);
  return builder_.Finish();
}

struct DTransferInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const DEntityInfo *super() const { return GetPointer<const DEntityInfo *>(4); }
  int32_t regionId() const { return GetField<int32_t>(6, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* super */) &&
           verifier.VerifyTable(super()) &&
           VerifyField<int32_t>(verifier, 6 /* regionId */) &&
           verifier.EndTable();
  }
};

struct DTransferInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_super(flatbuffers::Offset<DEntityInfo> super) { fbb_.AddOffset(4, super); }
  void add_regionId(int32_t regionId) { fbb_.AddElement<int32_t>(6, regionId, 0); }
  DTransferInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DTransferInfoBuilder &operator=(const DTransferInfoBuilder &);
  flatbuffers::Offset<DTransferInfo> Finish() {
    auto o = flatbuffers::Offset<DTransferInfo>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<DTransferInfo> CreateDTransferInfo(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<DEntityInfo> super = 0,
   int32_t regionId = 0) {
  DTransferInfoBuilder builder_(_fbb);
  builder_.add_regionId(regionId);
  builder_.add_super(super);
  return builder_.Finish();
}

struct DDecoratorInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const DEntityInfo *super() const { return GetPointer<const DEntityInfo *>(4); }
  const Vector3 *localScale() const { return GetStruct<const Vector3 *>(6); }
  const Quaternion *rotation() const { return GetStruct<const Quaternion *>(8); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* super */) &&
           verifier.VerifyTable(super()) &&
           VerifyField<Vector3>(verifier, 6 /* localScale */) &&
           VerifyField<Quaternion>(verifier, 8 /* rotation */) &&
           verifier.EndTable();
  }
};

struct DDecoratorInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_super(flatbuffers::Offset<DEntityInfo> super) { fbb_.AddOffset(4, super); }
  void add_localScale(const Vector3 *localScale) { fbb_.AddStruct(6, localScale); }
  void add_rotation(const Quaternion *rotation) { fbb_.AddStruct(8, rotation); }
  DDecoratorInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DDecoratorInfoBuilder &operator=(const DDecoratorInfoBuilder &);
  flatbuffers::Offset<DDecoratorInfo> Finish() {
    auto o = flatbuffers::Offset<DDecoratorInfo>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<DDecoratorInfo> CreateDDecoratorInfo(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<DEntityInfo> super = 0,
   const Vector3 *localScale = 0,
   const Quaternion *rotation = 0) {
  DDecoratorInfoBuilder builder_(_fbb);
  builder_.add_rotation(rotation);
  builder_.add_localScale(localScale);
  builder_.add_super(super);
  return builder_.Finish();
}

struct DDestructibleInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const DEntityInfo *super() const { return GetPointer<const DEntityInfo *>(4); }
  const Quaternion *rotation() const { return GetStruct<const Quaternion *>(6); }
  int32_t level() const { return GetField<int32_t>(8, 0); }
  int32_t flushGroupID() const { return GetField<int32_t>(10, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* super */) &&
           verifier.VerifyTable(super()) &&
           VerifyField<Quaternion>(verifier, 6 /* rotation */) &&
           VerifyField<int32_t>(verifier, 8 /* level */) &&
           VerifyField<int32_t>(verifier, 10 /* flushGroupID */) &&
           verifier.EndTable();
  }
};

struct DDestructibleInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_super(flatbuffers::Offset<DEntityInfo> super) { fbb_.AddOffset(4, super); }
  void add_rotation(const Quaternion *rotation) { fbb_.AddStruct(6, rotation); }
  void add_level(int32_t level) { fbb_.AddElement<int32_t>(8, level, 0); }
  void add_flushGroupID(int32_t flushGroupID) { fbb_.AddElement<int32_t>(10, flushGroupID, 0); }
  DDestructibleInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DDestructibleInfoBuilder &operator=(const DDestructibleInfoBuilder &);
  flatbuffers::Offset<DDestructibleInfo> Finish() {
    auto o = flatbuffers::Offset<DDestructibleInfo>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<DDestructibleInfo> CreateDDestructibleInfo(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<DEntityInfo> super = 0,
   const Quaternion *rotation = 0,
   int32_t level = 0,
   int32_t flushGroupID = 0) {
  DDestructibleInfoBuilder builder_(_fbb);
  builder_.add_flushGroupID(flushGroupID);
  builder_.add_level(level);
  builder_.add_rotation(rotation);
  builder_.add_super(super);
  return builder_.Finish();
}

struct DRegionInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const DEntityInfo *super() const { return GetPointer<const DEntityInfo *>(4); }
  RegionType regiontype() const { return static_cast<RegionType>(GetField<int8_t>(6, 0)); }
  const Vector2 *rect() const { return GetStruct<const Vector2 *>(8); }
  float radius() const { return GetField<float>(10, 1.0); }
  const Quaternion *rotation() const { return GetStruct<const Quaternion *>(12); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* super */) &&
           verifier.VerifyTable(super()) &&
           VerifyField<int8_t>(verifier, 6 /* regiontype */) &&
           VerifyField<Vector2>(verifier, 8 /* rect */) &&
           VerifyField<float>(verifier, 10 /* radius */) &&
           VerifyField<Quaternion>(verifier, 12 /* rotation */) &&
           verifier.EndTable();
  }
};

struct DRegionInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_super(flatbuffers::Offset<DEntityInfo> super) { fbb_.AddOffset(4, super); }
  void add_regiontype(RegionType regiontype) { fbb_.AddElement<int8_t>(6, static_cast<int8_t>(regiontype), 0); }
  void add_rect(const Vector2 *rect) { fbb_.AddStruct(8, rect); }
  void add_radius(float radius) { fbb_.AddElement<float>(10, radius, 1.0); }
  void add_rotation(const Quaternion *rotation) { fbb_.AddStruct(12, rotation); }
  DRegionInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DRegionInfoBuilder &operator=(const DRegionInfoBuilder &);
  flatbuffers::Offset<DRegionInfo> Finish() {
    auto o = flatbuffers::Offset<DRegionInfo>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<DRegionInfo> CreateDRegionInfo(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<DEntityInfo> super = 0,
   RegionType regiontype = RegionType_Circle,
   const Vector2 *rect = 0,
   float radius = 1.0,
   const Quaternion *rotation = 0) {
  DRegionInfoBuilder builder_(_fbb);
  builder_.add_rotation(rotation);
  builder_.add_radius(radius);
  builder_.add_rect(rect);
  builder_.add_super(super);
  builder_.add_regiontype(regiontype);
  return builder_.Finish();
}

struct DTransportDoor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const DRegionInfo *super() const { return GetPointer<const DRegionInfo *>(4); }
  uint8_t iseggdoor() const { return GetField<uint8_t>(6, 0); }
  TransportDoorType doortype() const { return static_cast<TransportDoorType>(GetField<int8_t>(8, 0)); }
  int32_t nextsceneid() const { return GetField<int32_t>(10, 0); }
  const flatbuffers::String *townscenepath() const { return GetPointer<const flatbuffers::String *>(12); }
  TransportDoorType nextdoortype() const { return static_cast<TransportDoorType>(GetField<int8_t>(14, 0)); }
  const Vector3 *birthposition() const { return GetStruct<const Vector3 *>(16); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* super */) &&
           verifier.VerifyTable(super()) &&
           VerifyField<uint8_t>(verifier, 6 /* iseggdoor */) &&
           VerifyField<int8_t>(verifier, 8 /* doortype */) &&
           VerifyField<int32_t>(verifier, 10 /* nextsceneid */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 12 /* townscenepath */) &&
           verifier.Verify(townscenepath()) &&
           VerifyField<int8_t>(verifier, 14 /* nextdoortype */) &&
           VerifyField<Vector3>(verifier, 16 /* birthposition */) &&
           verifier.EndTable();
  }
};

struct DTransportDoorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_super(flatbuffers::Offset<DRegionInfo> super) { fbb_.AddOffset(4, super); }
  void add_iseggdoor(uint8_t iseggdoor) { fbb_.AddElement<uint8_t>(6, iseggdoor, 0); }
  void add_doortype(TransportDoorType doortype) { fbb_.AddElement<int8_t>(8, static_cast<int8_t>(doortype), 0); }
  void add_nextsceneid(int32_t nextsceneid) { fbb_.AddElement<int32_t>(10, nextsceneid, 0); }
  void add_townscenepath(flatbuffers::Offset<flatbuffers::String> townscenepath) { fbb_.AddOffset(12, townscenepath); }
  void add_nextdoortype(TransportDoorType nextdoortype) { fbb_.AddElement<int8_t>(14, static_cast<int8_t>(nextdoortype), 0); }
  void add_birthposition(const Vector3 *birthposition) { fbb_.AddStruct(16, birthposition); }
  DTransportDoorBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DTransportDoorBuilder &operator=(const DTransportDoorBuilder &);
  flatbuffers::Offset<DTransportDoor> Finish() {
    auto o = flatbuffers::Offset<DTransportDoor>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<DTransportDoor> CreateDTransportDoor(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<DRegionInfo> super = 0,
   uint8_t iseggdoor = 0,
   TransportDoorType doortype = TransportDoorType_Left,
   int32_t nextsceneid = 0,
   flatbuffers::Offset<flatbuffers::String> townscenepath = 0,
   TransportDoorType nextdoortype = TransportDoorType_Left,
   const Vector3 *birthposition = 0) {
  DTransportDoorBuilder builder_(_fbb);
  builder_.add_birthposition(birthposition);
  builder_.add_townscenepath(townscenepath);
  builder_.add_nextsceneid(nextsceneid);
  builder_.add_super(super);
  builder_.add_nextdoortype(nextdoortype);
  builder_.add_doortype(doortype);
  builder_.add_iseggdoor(iseggdoor);
  return builder_.Finish();
}

struct DTownDoor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const DRegionInfo *super() const { return GetPointer<const DRegionInfo *>(4); }
  int32_t SceneID() const { return GetField<int32_t>(6, 0); }
  int32_t DoorID() const { return GetField<int32_t>(8, 0); }
  const Vector3 *BirthPos() const { return GetStruct<const Vector3 *>(10); }
  int32_t TargetSceneID() const { return GetField<int32_t>(12, 0); }
  int32_t TargetDoorID() const { return GetField<int32_t>(14, 0); }
  DoorTargetType DoorType() const { return static_cast<DoorTargetType>(GetField<int8_t>(16, 0)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* super */) &&
           verifier.VerifyTable(super()) &&
           VerifyField<int32_t>(verifier, 6 /* SceneID */) &&
           VerifyField<int32_t>(verifier, 8 /* DoorID */) &&
           VerifyField<Vector3>(verifier, 10 /* BirthPos */) &&
           VerifyField<int32_t>(verifier, 12 /* TargetSceneID */) &&
           VerifyField<int32_t>(verifier, 14 /* TargetDoorID */) &&
           VerifyField<int8_t>(verifier, 16 /* DoorType */) &&
           verifier.EndTable();
  }
};

struct DTownDoorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_super(flatbuffers::Offset<DRegionInfo> super) { fbb_.AddOffset(4, super); }
  void add_SceneID(int32_t SceneID) { fbb_.AddElement<int32_t>(6, SceneID, 0); }
  void add_DoorID(int32_t DoorID) { fbb_.AddElement<int32_t>(8, DoorID, 0); }
  void add_BirthPos(const Vector3 *BirthPos) { fbb_.AddStruct(10, BirthPos); }
  void add_TargetSceneID(int32_t TargetSceneID) { fbb_.AddElement<int32_t>(12, TargetSceneID, 0); }
  void add_TargetDoorID(int32_t TargetDoorID) { fbb_.AddElement<int32_t>(14, TargetDoorID, 0); }
  void add_DoorType(DoorTargetType DoorType) { fbb_.AddElement<int8_t>(16, static_cast<int8_t>(DoorType), 0); }
  DTownDoorBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DTownDoorBuilder &operator=(const DTownDoorBuilder &);
  flatbuffers::Offset<DTownDoor> Finish() {
    auto o = flatbuffers::Offset<DTownDoor>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<DTownDoor> CreateDTownDoor(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<DRegionInfo> super = 0,
   int32_t SceneID = 0,
   int32_t DoorID = 0,
   const Vector3 *BirthPos = 0,
   int32_t TargetSceneID = 0,
   int32_t TargetDoorID = 0,
   DoorTargetType DoorType = DoorTargetType_Normal) {
  DTownDoorBuilder builder_(_fbb);
  builder_.add_TargetDoorID(TargetDoorID);
  builder_.add_TargetSceneID(TargetSceneID);
  builder_.add_BirthPos(BirthPos);
  builder_.add_DoorID(DoorID);
  builder_.add_SceneID(SceneID);
  builder_.add_super(super);
  builder_.add_DoorType(DoorType);
  return builder_.Finish();
}

struct DSceneData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  int32_t id() const { return GetField<int32_t>(6, 0); }
  const flatbuffers::String *prefabpath() const { return GetPointer<const flatbuffers::String *>(8); }
  float CameraLookHeight() const { return GetField<float>(10, 1.0); }
  float CameraDistance() const { return GetField<float>(12, 10.0); }
  float CameraAngle() const { return GetField<float>(14, 20.0); }
  float CameraNearClip() const { return GetField<float>(16, 0.3); }
  float CameraFarClip() const { return GetField<float>(18, 50.0); }
  float CameraSize() const { return GetField<float>(20, 3.3); }
  const Vector2 *CameraZRange() const { return GetStruct<const Vector2 *>(22); }
  const Vector2 *CameraXRange() const { return GetStruct<const Vector2 *>(24); }
  uint8_t CameraPersp() const { return GetField<uint8_t>(26, 0); }
  const Vector3 *CenterPostionNew() const { return GetStruct<const Vector3 *>(28); }
  const Vector3 *ScenePostion() const { return GetStruct<const Vector3 *>(30); }
  float SceneUScale() const { return GetField<float>(32, 1.0); }
  const Vector2 *GridSize() const { return GetStruct<const Vector2 *>(34); }
  const Vector2 *LogicXSize() const { return GetStruct<const Vector2 *>(36); }
  const Vector2 *LogicZSize() const { return GetStruct<const Vector2 *>(38); }
  const Color *ObjectDyeColor() const { return GetStruct<const Color *>(40); }
  const Vector3 *LogicPos() const { return GetStruct<const Vector3 *>(42); }
  EWeatherMode WeatherMode() const { return static_cast<EWeatherMode>(GetField<int8_t>(44, 0)); }
  int32_t TipsID() const { return GetField<int32_t>(46, 0); }
  const flatbuffers::String *LightmapsettingsPath() const { return GetPointer<const flatbuffers::String *>(48); }
  int32_t LogicXmin() const { return GetField<int32_t>(50, 0); }
  int32_t LogicXmax() const { return GetField<int32_t>(52, 0); }
  int32_t LogicZmin() const { return GetField<int32_t>(54, 0); }
  int32_t LogicZmax() const { return GetField<int32_t>(56, 0); }
  const flatbuffers::Vector<flatbuffers::Offset<DEntityInfo>> *entityinfo() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DEntityInfo>> *>(58); }
  const flatbuffers::Vector<uint8_t> *blocklayer() const { return GetPointer<const flatbuffers::Vector<uint8_t> *>(60); }
  const flatbuffers::Vector<flatbuffers::Offset<DNPCInfo>> *npcinfo() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DNPCInfo>> *>(62); }
  const flatbuffers::Vector<flatbuffers::Offset<DMonsterInfo>> *monsterinfo() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DMonsterInfo>> *>(64); }
  const flatbuffers::Vector<flatbuffers::Offset<DDecoratorInfo>> *decoratorinfo() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DDecoratorInfo>> *>(66); }
  const flatbuffers::Vector<flatbuffers::Offset<DDestructibleInfo>> *desructibleinfo() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DDestructibleInfo>> *>(68); }
  const flatbuffers::Vector<flatbuffers::Offset<DRegionInfo>> *regioninfo() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DRegionInfo>> *>(70); }
  const flatbuffers::Vector<flatbuffers::Offset<DTransportDoor>> *transportdoor() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DTransportDoor>> *>(72); }
  const flatbuffers::Vector<flatbuffers::Offset<DTransferInfo>> *fighterBornPosition() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DTransferInfo>> *>(74); }
  const DEntityInfo *birthposition() const { return GetPointer<const DEntityInfo *>(76); }
  const DEntityInfo *hellbirthposition() const { return GetPointer<const DEntityInfo *>(78); }
  const flatbuffers::Vector<flatbuffers::Offset<DTownDoor>> *townDoor() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DTownDoor>> *>(80); }
  const flatbuffers::Vector<flatbuffers::Offset<FunctionPrefab>> *FunctionPrefab() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FunctionPrefab>> *>(82); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, 6 /* id */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* prefabpath */) &&
           verifier.Verify(prefabpath()) &&
           VerifyField<float>(verifier, 10 /* CameraLookHeight */) &&
           VerifyField<float>(verifier, 12 /* CameraDistance */) &&
           VerifyField<float>(verifier, 14 /* CameraAngle */) &&
           VerifyField<float>(verifier, 16 /* CameraNearClip */) &&
           VerifyField<float>(verifier, 18 /* CameraFarClip */) &&
           VerifyField<float>(verifier, 20 /* CameraSize */) &&
           VerifyField<Vector2>(verifier, 22 /* CameraZRange */) &&
           VerifyField<Vector2>(verifier, 24 /* CameraXRange */) &&
           VerifyField<uint8_t>(verifier, 26 /* CameraPersp */) &&
           VerifyField<Vector3>(verifier, 28 /* CenterPostionNew */) &&
           VerifyField<Vector3>(verifier, 30 /* ScenePostion */) &&
           VerifyField<float>(verifier, 32 /* SceneUScale */) &&
           VerifyField<Vector2>(verifier, 34 /* GridSize */) &&
           VerifyField<Vector2>(verifier, 36 /* LogicXSize */) &&
           VerifyField<Vector2>(verifier, 38 /* LogicZSize */) &&
           VerifyField<Color>(verifier, 40 /* ObjectDyeColor */) &&
           VerifyField<Vector3>(verifier, 42 /* LogicPos */) &&
           VerifyField<int8_t>(verifier, 44 /* WeatherMode */) &&
           VerifyField<int32_t>(verifier, 46 /* TipsID */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 48 /* LightmapsettingsPath */) &&
           verifier.Verify(LightmapsettingsPath()) &&
           VerifyField<int32_t>(verifier, 50 /* LogicXmin */) &&
           VerifyField<int32_t>(verifier, 52 /* LogicXmax */) &&
           VerifyField<int32_t>(verifier, 54 /* LogicZmin */) &&
           VerifyField<int32_t>(verifier, 56 /* LogicZmax */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 58 /* entityinfo */) &&
           verifier.Verify(entityinfo()) &&
           verifier.VerifyVectorOfTables(entityinfo()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 60 /* blocklayer */) &&
           verifier.Verify(blocklayer()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 62 /* npcinfo */) &&
           verifier.Verify(npcinfo()) &&
           verifier.VerifyVectorOfTables(npcinfo()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 64 /* monsterinfo */) &&
           verifier.Verify(monsterinfo()) &&
           verifier.VerifyVectorOfTables(monsterinfo()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 66 /* decoratorinfo */) &&
           verifier.Verify(decoratorinfo()) &&
           verifier.VerifyVectorOfTables(decoratorinfo()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 68 /* desructibleinfo */) &&
           verifier.Verify(desructibleinfo()) &&
           verifier.VerifyVectorOfTables(desructibleinfo()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 70 /* regioninfo */) &&
           verifier.Verify(regioninfo()) &&
           verifier.VerifyVectorOfTables(regioninfo()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 72 /* transportdoor */) &&
           verifier.Verify(transportdoor()) &&
           verifier.VerifyVectorOfTables(transportdoor()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 74 /* fighterBornPosition */) &&
           verifier.Verify(fighterBornPosition()) &&
           verifier.VerifyVectorOfTables(fighterBornPosition()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 76 /* birthposition */) &&
           verifier.VerifyTable(birthposition()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 78 /* hellbirthposition */) &&
           verifier.VerifyTable(hellbirthposition()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 80 /* townDoor */) &&
           verifier.Verify(townDoor()) &&
           verifier.VerifyVectorOfTables(townDoor()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 82 /* FunctionPrefab */) &&
           verifier.Verify(FunctionPrefab()) &&
           verifier.VerifyVectorOfTables(FunctionPrefab()) &&
           verifier.EndTable();
  }
};

struct DSceneDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_id(int32_t id) { fbb_.AddElement<int32_t>(6, id, 0); }
  void add_prefabpath(flatbuffers::Offset<flatbuffers::String> prefabpath) { fbb_.AddOffset(8, prefabpath); }
  void add_CameraLookHeight(float CameraLookHeight) { fbb_.AddElement<float>(10, CameraLookHeight, 1.0); }
  void add_CameraDistance(float CameraDistance) { fbb_.AddElement<float>(12, CameraDistance, 10.0); }
  void add_CameraAngle(float CameraAngle) { fbb_.AddElement<float>(14, CameraAngle, 20.0); }
  void add_CameraNearClip(float CameraNearClip) { fbb_.AddElement<float>(16, CameraNearClip, 0.3); }
  void add_CameraFarClip(float CameraFarClip) { fbb_.AddElement<float>(18, CameraFarClip, 50.0); }
  void add_CameraSize(float CameraSize) { fbb_.AddElement<float>(20, CameraSize, 3.3); }
  void add_CameraZRange(const Vector2 *CameraZRange) { fbb_.AddStruct(22, CameraZRange); }
  void add_CameraXRange(const Vector2 *CameraXRange) { fbb_.AddStruct(24, CameraXRange); }
  void add_CameraPersp(uint8_t CameraPersp) { fbb_.AddElement<uint8_t>(26, CameraPersp, 0); }
  void add_CenterPostionNew(const Vector3 *CenterPostionNew) { fbb_.AddStruct(28, CenterPostionNew); }
  void add_ScenePostion(const Vector3 *ScenePostion) { fbb_.AddStruct(30, ScenePostion); }
  void add_SceneUScale(float SceneUScale) { fbb_.AddElement<float>(32, SceneUScale, 1.0); }
  void add_GridSize(const Vector2 *GridSize) { fbb_.AddStruct(34, GridSize); }
  void add_LogicXSize(const Vector2 *LogicXSize) { fbb_.AddStruct(36, LogicXSize); }
  void add_LogicZSize(const Vector2 *LogicZSize) { fbb_.AddStruct(38, LogicZSize); }
  void add_ObjectDyeColor(const Color *ObjectDyeColor) { fbb_.AddStruct(40, ObjectDyeColor); }
  void add_LogicPos(const Vector3 *LogicPos) { fbb_.AddStruct(42, LogicPos); }
  void add_WeatherMode(EWeatherMode WeatherMode) { fbb_.AddElement<int8_t>(44, static_cast<int8_t>(WeatherMode), 0); }
  void add_TipsID(int32_t TipsID) { fbb_.AddElement<int32_t>(46, TipsID, 0); }
  void add_LightmapsettingsPath(flatbuffers::Offset<flatbuffers::String> LightmapsettingsPath) { fbb_.AddOffset(48, LightmapsettingsPath); }
  void add_LogicXmin(int32_t LogicXmin) { fbb_.AddElement<int32_t>(50, LogicXmin, 0); }
  void add_LogicXmax(int32_t LogicXmax) { fbb_.AddElement<int32_t>(52, LogicXmax, 0); }
  void add_LogicZmin(int32_t LogicZmin) { fbb_.AddElement<int32_t>(54, LogicZmin, 0); }
  void add_LogicZmax(int32_t LogicZmax) { fbb_.AddElement<int32_t>(56, LogicZmax, 0); }
  void add_entityinfo(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DEntityInfo>>> entityinfo) { fbb_.AddOffset(58, entityinfo); }
  void add_blocklayer(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> blocklayer) { fbb_.AddOffset(60, blocklayer); }
  void add_npcinfo(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DNPCInfo>>> npcinfo) { fbb_.AddOffset(62, npcinfo); }
  void add_monsterinfo(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DMonsterInfo>>> monsterinfo) { fbb_.AddOffset(64, monsterinfo); }
  void add_decoratorinfo(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DDecoratorInfo>>> decoratorinfo) { fbb_.AddOffset(66, decoratorinfo); }
  void add_desructibleinfo(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DDestructibleInfo>>> desructibleinfo) { fbb_.AddOffset(68, desructibleinfo); }
  void add_regioninfo(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DRegionInfo>>> regioninfo) { fbb_.AddOffset(70, regioninfo); }
  void add_transportdoor(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DTransportDoor>>> transportdoor) { fbb_.AddOffset(72, transportdoor); }
  void add_fighterBornPosition(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DTransferInfo>>> fighterBornPosition) { fbb_.AddOffset(74, fighterBornPosition); }
  void add_birthposition(flatbuffers::Offset<DEntityInfo> birthposition) { fbb_.AddOffset(76, birthposition); }
  void add_hellbirthposition(flatbuffers::Offset<DEntityInfo> hellbirthposition) { fbb_.AddOffset(78, hellbirthposition); }
  void add_townDoor(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DTownDoor>>> townDoor) { fbb_.AddOffset(80, townDoor); }
  void add_FunctionPrefab(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FunctionPrefab>>> FunctionPrefab) { fbb_.AddOffset(82, FunctionPrefab); }
  DSceneDataBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DSceneDataBuilder &operator=(const DSceneDataBuilder &);
  flatbuffers::Offset<DSceneData> Finish() {
    auto o = flatbuffers::Offset<DSceneData>(fbb_.EndTable(start_, 40));
    return o;
  }
};

inline flatbuffers::Offset<DSceneData> CreateDSceneData(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   int32_t id = 0,
   flatbuffers::Offset<flatbuffers::String> prefabpath = 0,
   float CameraLookHeight = 1.0,
   float CameraDistance = 10.0,
   float CameraAngle = 20.0,
   float CameraNearClip = 0.3,
   float CameraFarClip = 50.0,
   float CameraSize = 3.3,
   const Vector2 *CameraZRange = 0,
   const Vector2 *CameraXRange = 0,
   uint8_t CameraPersp = 0,
   const Vector3 *CenterPostionNew = 0,
   const Vector3 *ScenePostion = 0,
   float SceneUScale = 1.0,
   const Vector2 *GridSize = 0,
   const Vector2 *LogicXSize = 0,
   const Vector2 *LogicZSize = 0,
   const Color *ObjectDyeColor = 0,
   const Vector3 *LogicPos = 0,
   EWeatherMode WeatherMode = EWeatherMode_None,
   int32_t TipsID = 0,
   flatbuffers::Offset<flatbuffers::String> LightmapsettingsPath = 0,
   int32_t LogicXmin = 0,
   int32_t LogicXmax = 0,
   int32_t LogicZmin = 0,
   int32_t LogicZmax = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DEntityInfo>>> entityinfo = 0,
   flatbuffers::Offset<flatbuffers::Vector<uint8_t>> blocklayer = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DNPCInfo>>> npcinfo = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DMonsterInfo>>> monsterinfo = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DDecoratorInfo>>> decoratorinfo = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DDestructibleInfo>>> desructibleinfo = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DRegionInfo>>> regioninfo = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DTransportDoor>>> transportdoor = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DTransferInfo>>> fighterBornPosition = 0,
   flatbuffers::Offset<DEntityInfo> birthposition = 0,
   flatbuffers::Offset<DEntityInfo> hellbirthposition = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DTownDoor>>> townDoor = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FunctionPrefab>>> FunctionPrefab = 0) {
  DSceneDataBuilder builder_(_fbb);
  builder_.add_FunctionPrefab(FunctionPrefab);
  builder_.add_townDoor(townDoor);
  builder_.add_hellbirthposition(hellbirthposition);
  builder_.add_birthposition(birthposition);
  builder_.add_fighterBornPosition(fighterBornPosition);
  builder_.add_transportdoor(transportdoor);
  builder_.add_regioninfo(regioninfo);
  builder_.add_desructibleinfo(desructibleinfo);
  builder_.add_decoratorinfo(decoratorinfo);
  builder_.add_monsterinfo(monsterinfo);
  builder_.add_npcinfo(npcinfo);
  builder_.add_blocklayer(blocklayer);
  builder_.add_entityinfo(entityinfo);
  builder_.add_LogicZmax(LogicZmax);
  builder_.add_LogicZmin(LogicZmin);
  builder_.add_LogicXmax(LogicXmax);
  builder_.add_LogicXmin(LogicXmin);
  builder_.add_LightmapsettingsPath(LightmapsettingsPath);
  builder_.add_TipsID(TipsID);
  builder_.add_LogicPos(LogicPos);
  builder_.add_ObjectDyeColor(ObjectDyeColor);
  builder_.add_LogicZSize(LogicZSize);
  builder_.add_LogicXSize(LogicXSize);
  builder_.add_GridSize(GridSize);
  builder_.add_SceneUScale(SceneUScale);
  builder_.add_ScenePostion(ScenePostion);
  builder_.add_CenterPostionNew(CenterPostionNew);
  builder_.add_CameraXRange(CameraXRange);
  builder_.add_CameraZRange(CameraZRange);
  builder_.add_CameraSize(CameraSize);
  builder_.add_CameraFarClip(CameraFarClip);
  builder_.add_CameraNearClip(CameraNearClip);
  builder_.add_CameraAngle(CameraAngle);
  builder_.add_CameraDistance(CameraDistance);
  builder_.add_CameraLookHeight(CameraLookHeight);
  builder_.add_prefabpath(prefabpath);
  builder_.add_id(id);
  builder_.add_name(name);
  builder_.add_WeatherMode(WeatherMode);
  builder_.add_CameraPersp(CameraPersp);
  return builder_.Finish();
}

inline const FBSceneData::DSceneData *GetDSceneData(const void *buf) { return flatbuffers::GetRoot<FBSceneData::DSceneData>(buf); }

inline bool VerifyDSceneDataBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<FBSceneData::DSceneData>(); }

inline const char *DSceneDataIdentifier() { return "SCEN"; }

inline bool DSceneDataBufferHasIdentifier(const void *buf) { return flatbuffers::BufferHasIdentifier(buf, DSceneDataIdentifier()); }

inline void FinishDSceneDataBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<FBSceneData::DSceneData> root) { fbb.Finish(root, DSceneDataIdentifier()); }

}  // namespace FBSceneData

#endif  // FLATBUFFERS_GENERATED_FBSCENEDATA_FBSCENEDATA_H_
