// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_FBDUNGEONDATA_FBDUNGEONDATA_H_
#define FLATBUFFERS_GENERATED_FBDUNGEONDATA_FBDUNGEONDATA_H_

#include "flatbuffers/flatbuffers.h"


namespace FBDungeonData {

struct DSceneDataConnect;
struct DDungeonData;

struct DSceneDataConnect FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::Vector<uint8_t> *isconnect() const { return GetPointer<const flatbuffers::Vector<uint8_t> *>(4); }
  const flatbuffers::Vector<int32_t> *linkAreaIndex() const { return GetPointer<const flatbuffers::Vector<int32_t> *>(6); }
  int32_t areaindex() const { return GetField<int32_t>(8, -1); }
  int32_t id() const { return GetField<int32_t>(10, 0); }
  const flatbuffers::String *sceneareapath() const { return GetPointer<const flatbuffers::String *>(12); }
  int32_t positionx() const { return GetField<int32_t>(14, -1); }
  int32_t positiony() const { return GetField<int32_t>(16, -1); }
  uint8_t isboss() const { return GetField<uint8_t>(18, 0); }
  uint8_t isstart() const { return GetField<uint8_t>(20, 0); }
  uint8_t isegg() const { return GetField<uint8_t>(22, 0); }
  uint8_t isnothell() const { return GetField<uint8_t>(24, 0); }
  uint8_t treasureType() const { return GetField<uint8_t>(26, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* isconnect */) &&
           verifier.Verify(isconnect()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* linkAreaIndex */) &&
           verifier.Verify(linkAreaIndex()) &&
           VerifyField<int32_t>(verifier, 8 /* areaindex */) &&
           VerifyField<int32_t>(verifier, 10 /* id */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 12 /* sceneareapath */) &&
           verifier.Verify(sceneareapath()) &&
           VerifyField<int32_t>(verifier, 14 /* positionx */) &&
           VerifyField<int32_t>(verifier, 16 /* positiony */) &&
           VerifyField<uint8_t>(verifier, 18 /* isboss */) &&
           VerifyField<uint8_t>(verifier, 20 /* isstart */) &&
           VerifyField<uint8_t>(verifier, 22 /* isegg */) &&
           VerifyField<uint8_t>(verifier, 24 /* isnothell */) &&
           VerifyField<uint8_t>(verifier, 26 /* treasureType */) &&
           verifier.EndTable();
  }
};

struct DSceneDataConnectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_isconnect(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> isconnect) { fbb_.AddOffset(4, isconnect); }
  void add_linkAreaIndex(flatbuffers::Offset<flatbuffers::Vector<int32_t>> linkAreaIndex) { fbb_.AddOffset(6, linkAreaIndex); }
  void add_areaindex(int32_t areaindex) { fbb_.AddElement<int32_t>(8, areaindex, -1); }
  void add_id(int32_t id) { fbb_.AddElement<int32_t>(10, id, 0); }
  void add_sceneareapath(flatbuffers::Offset<flatbuffers::String> sceneareapath) { fbb_.AddOffset(12, sceneareapath); }
  void add_positionx(int32_t positionx) { fbb_.AddElement<int32_t>(14, positionx, -1); }
  void add_positiony(int32_t positiony) { fbb_.AddElement<int32_t>(16, positiony, -1); }
  void add_isboss(uint8_t isboss) { fbb_.AddElement<uint8_t>(18, isboss, 0); }
  void add_isstart(uint8_t isstart) { fbb_.AddElement<uint8_t>(20, isstart, 0); }
  void add_isegg(uint8_t isegg) { fbb_.AddElement<uint8_t>(22, isegg, 0); }
  void add_isnothell(uint8_t isnothell) { fbb_.AddElement<uint8_t>(24, isnothell, 0); }
  void add_treasureType(uint8_t treasureType) { fbb_.AddElement<uint8_t>(26, treasureType, 0); }
  DSceneDataConnectBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DSceneDataConnectBuilder &operator=(const DSceneDataConnectBuilder &);
  flatbuffers::Offset<DSceneDataConnect> Finish() {
    auto o = flatbuffers::Offset<DSceneDataConnect>(fbb_.EndTable(start_, 12));
    return o;
  }
};

inline flatbuffers::Offset<DSceneDataConnect> CreateDSceneDataConnect(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<uint8_t>> isconnect = 0,
   flatbuffers::Offset<flatbuffers::Vector<int32_t>> linkAreaIndex = 0,
   int32_t areaindex = -1,
   int32_t id = 0,
   flatbuffers::Offset<flatbuffers::String> sceneareapath = 0,
   int32_t positionx = -1,
   int32_t positiony = -1,
   uint8_t isboss = 0,
   uint8_t isstart = 0,
   uint8_t isegg = 0,
   uint8_t isnothell = 0,
   uint8_t treasureType = 0) {
  DSceneDataConnectBuilder builder_(_fbb);
  builder_.add_positiony(positiony);
  builder_.add_positionx(positionx);
  builder_.add_sceneareapath(sceneareapath);
  builder_.add_id(id);
  builder_.add_areaindex(areaindex);
  builder_.add_linkAreaIndex(linkAreaIndex);
  builder_.add_isconnect(isconnect);
  builder_.add_treasureType(treasureType);
  builder_.add_isnothell(isnothell);
  builder_.add_isegg(isegg);
  builder_.add_isstart(isstart);
  builder_.add_isboss(isboss);
  return builder_.Finish();
}

struct DDungeonData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  int32_t height() const { return GetField<int32_t>(6, 3); }
  int32_t weidth() const { return GetField<int32_t>(8, 3); }
  int32_t startindex() const { return GetField<int32_t>(10, 0); }
  const flatbuffers::Vector<flatbuffers::Offset<DSceneDataConnect>> *areaconnectlist() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DSceneDataConnect>> *>(12); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, 6 /* height */) &&
           VerifyField<int32_t>(verifier, 8 /* weidth */) &&
           VerifyField<int32_t>(verifier, 10 /* startindex */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 12 /* areaconnectlist */) &&
           verifier.Verify(areaconnectlist()) &&
           verifier.VerifyVectorOfTables(areaconnectlist()) &&
           verifier.EndTable();
  }
};

struct DDungeonDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_height(int32_t height) { fbb_.AddElement<int32_t>(6, height, 3); }
  void add_weidth(int32_t weidth) { fbb_.AddElement<int32_t>(8, weidth, 3); }
  void add_startindex(int32_t startindex) { fbb_.AddElement<int32_t>(10, startindex, 0); }
  void add_areaconnectlist(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DSceneDataConnect>>> areaconnectlist) { fbb_.AddOffset(12, areaconnectlist); }
  DDungeonDataBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DDungeonDataBuilder &operator=(const DDungeonDataBuilder &);
  flatbuffers::Offset<DDungeonData> Finish() {
    auto o = flatbuffers::Offset<DDungeonData>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<DDungeonData> CreateDDungeonData(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   int32_t height = 3,
   int32_t weidth = 3,
   int32_t startindex = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DSceneDataConnect>>> areaconnectlist = 0) {
  DDungeonDataBuilder builder_(_fbb);
  builder_.add_areaconnectlist(areaconnectlist);
  builder_.add_startindex(startindex);
  builder_.add_weidth(weidth);
  builder_.add_height(height);
  builder_.add_name(name);
  return builder_.Finish();
}

inline const FBDungeonData::DDungeonData *GetDDungeonData(const void *buf) { return flatbuffers::GetRoot<FBDungeonData::DDungeonData>(buf); }

inline bool VerifyDDungeonDataBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<FBDungeonData::DDungeonData>(); }

inline const char *DDungeonDataIdentifier() { return "DUNG"; }

inline bool DDungeonDataBufferHasIdentifier(const void *buf) { return flatbuffers::BufferHasIdentifier(buf, DDungeonDataIdentifier()); }

inline void FinishDDungeonDataBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<FBDungeonData::DDungeonData> root) { fbb.Finish(root, DDungeonDataIdentifier()); }

}  // namespace FBDungeonData

#endif  // FLATBUFFERS_GENERATED_FBDUNGEONDATA_FBDUNGEONDATA_H_
