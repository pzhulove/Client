// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_FBSKILLDATA_FBSKILLDATA_H_
#define FLATBUFFERS_GENERATED_FBSKILLDATA_FBSKILLDATA_H_

#include "flatbuffers/flatbuffers.h"


namespace FBSkillData {

struct Vector2;
struct Vector3;
struct Quaternion;
struct ShapeBox;
struct HurtDecisionBox;
struct DefenceDecisionBox;
struct TransformParam;
struct EffectsFrames;
struct ShockInfo;
struct RandomLaunchInfo;
struct EntityFrames;
struct AnimationFrames;
struct EntityAttachFrames;
struct ChargeConfig;
struct OperationConfig;
struct SkillJoystickConfig;
struct SkillEvent;
struct boolValue;
struct floatValue;
struct intValue;
struct QuaternionValue;
struct uintValue;
struct Vector3Value;
struct DSkillPropertyModify;
struct DSkillFrameTag;
struct DSkillSfx;
struct DSkillFrameEffect;
struct DSkillCameraMove;
struct DSkillWalkControl;
struct DSkillFrameGrap;
struct DSkillFrameStateOp;
struct DSkillFaceAttacker;
struct DSkillFrameEventSceneShock;
struct DActionData;
struct DSkillBuff;
struct DSkillSummon;
struct DSkillMechanism;
struct FBSkillData;
struct FBSkillDataTable;
struct FBSkillDataCollection;

enum WeaponClassesOrWhatever {
  WeaponClassesOrWhatever_NONE = 0,
  WeaponClassesOrWhatever_boolValue = 1,
  WeaponClassesOrWhatever_floatValue = 2,
  WeaponClassesOrWhatever_intValue = 3,
  WeaponClassesOrWhatever_QuaternionValue = 4,
  WeaponClassesOrWhatever_uintValue = 5,
  WeaponClassesOrWhatever_Vector3Value = 6
};

inline const char **EnumNamesWeaponClassesOrWhatever() {
  static const char *names[] = { "NONE", "boolValue", "floatValue", "intValue", "QuaternionValue", "uintValue", "Vector3Value", nullptr };
  return names;
}

inline const char *EnumNameWeaponClassesOrWhatever(WeaponClassesOrWhatever e) { return EnumNamesWeaponClassesOrWhatever()[e]; }

inline bool VerifyWeaponClassesOrWhatever(flatbuffers::Verifier &verifier, const void *union_obj, WeaponClassesOrWhatever type);

MANUALLY_ALIGNED_STRUCT(4) Vector2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vector2(float x, float y)
    : x_(flatbuffers::EndianScalar(x)), y_(flatbuffers::EndianScalar(y)) { }

  float x() const { return flatbuffers::EndianScalar(x_); }
  float y() const { return flatbuffers::EndianScalar(y_); }
};
STRUCT_END(Vector2, 8);

MANUALLY_ALIGNED_STRUCT(4) Vector3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vector3(float x, float y, float z)
    : x_(flatbuffers::EndianScalar(x)), y_(flatbuffers::EndianScalar(y)), z_(flatbuffers::EndianScalar(z)) { }

  float x() const { return flatbuffers::EndianScalar(x_); }
  float y() const { return flatbuffers::EndianScalar(y_); }
  float z() const { return flatbuffers::EndianScalar(z_); }
};
STRUCT_END(Vector3, 12);

MANUALLY_ALIGNED_STRUCT(4) Quaternion FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Quaternion(float x, float y, float z, float w)
    : x_(flatbuffers::EndianScalar(x)), y_(flatbuffers::EndianScalar(y)), z_(flatbuffers::EndianScalar(z)), w_(flatbuffers::EndianScalar(w)) { }

  float x() const { return flatbuffers::EndianScalar(x_); }
  float y() const { return flatbuffers::EndianScalar(y_); }
  float z() const { return flatbuffers::EndianScalar(z_); }
  float w() const { return flatbuffers::EndianScalar(w_); }
};
STRUCT_END(Quaternion, 16);

MANUALLY_ALIGNED_STRUCT(4) TransformParam FLATBUFFERS_FINAL_CLASS {
 private:
  Vector3 localPosition_;
  Quaternion localRotation_;
  Vector3 localScale_;

 public:
  TransformParam(const Vector3 &localPosition, const Quaternion &localRotation, const Vector3 &localScale)
    : localPosition_(localPosition), localRotation_(localRotation), localScale_(localScale) { }

  const Vector3 &localPosition() const { return localPosition_; }
  const Quaternion &localRotation() const { return localRotation_; }
  const Vector3 &localScale() const { return localScale_; }
};
STRUCT_END(TransformParam, 40);

MANUALLY_ALIGNED_STRUCT(4) ShockInfo FLATBUFFERS_FINAL_CLASS {
 private:
  float shockTime_;
  float shockSpeed_;
  float shockRangeX_;
  float shockRangeY_;

 public:
  ShockInfo(float shockTime, float shockSpeed, float shockRangeX, float shockRangeY)
    : shockTime_(flatbuffers::EndianScalar(shockTime)), shockSpeed_(flatbuffers::EndianScalar(shockSpeed)), shockRangeX_(flatbuffers::EndianScalar(shockRangeX)), shockRangeY_(flatbuffers::EndianScalar(shockRangeY)) { }

  float shockTime() const { return flatbuffers::EndianScalar(shockTime_); }
  float shockSpeed() const { return flatbuffers::EndianScalar(shockSpeed_); }
  float shockRangeX() const { return flatbuffers::EndianScalar(shockRangeX_); }
  float shockRangeY() const { return flatbuffers::EndianScalar(shockRangeY_); }
};
STRUCT_END(ShockInfo, 16);

MANUALLY_ALIGNED_STRUCT(4) RandomLaunchInfo FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t num_;
  uint8_t isNumRand_;
  int8_t __padding0;
  int16_t __padding1;
  Vector2 numRandRange_;
  float interval_;
  float rangeRadius_;
  uint8_t isFullScene_;
  int8_t __padding2;
  int16_t __padding3;

 public:
  RandomLaunchInfo(int32_t num, uint8_t isNumRand, const Vector2 &numRandRange, float interval, float rangeRadius, uint8_t isFullScene)
    : num_(flatbuffers::EndianScalar(num)), isNumRand_(flatbuffers::EndianScalar(isNumRand)), __padding0(0), __padding1(0), numRandRange_(numRandRange), interval_(flatbuffers::EndianScalar(interval)), rangeRadius_(flatbuffers::EndianScalar(rangeRadius)), isFullScene_(flatbuffers::EndianScalar(isFullScene)), __padding2(0), __padding3(0) { (void)__padding0; (void)__padding1; (void)__padding2; (void)__padding3; }

  int32_t num() const { return flatbuffers::EndianScalar(num_); }
  uint8_t isNumRand() const { return flatbuffers::EndianScalar(isNumRand_); }
  const Vector2 &numRandRange() const { return numRandRange_; }
  float interval() const { return flatbuffers::EndianScalar(interval_); }
  float rangeRadius() const { return flatbuffers::EndianScalar(rangeRadius_); }
  uint8_t isFullScene() const { return flatbuffers::EndianScalar(isFullScene_); }
};
STRUCT_END(RandomLaunchInfo, 28);

struct ShapeBox FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const Vector2 *size() const { return GetStruct<const Vector2 *>(4); }
  const Vector2 *center() const { return GetStruct<const Vector2 *>(6); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vector2>(verifier, 4 /* size */) &&
           VerifyField<Vector2>(verifier, 6 /* center */) &&
           verifier.EndTable();
  }
};

struct ShapeBoxBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_size(const Vector2 *size) { fbb_.AddStruct(4, size); }
  void add_center(const Vector2 *center) { fbb_.AddStruct(6, center); }
  ShapeBoxBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ShapeBoxBuilder &operator=(const ShapeBoxBuilder &);
  flatbuffers::Offset<ShapeBox> Finish() {
    auto o = flatbuffers::Offset<ShapeBox>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<ShapeBox> CreateShapeBox(flatbuffers::FlatBufferBuilder &_fbb,
   const Vector2 *size = 0,
   const Vector2 *center = 0) {
  ShapeBoxBuilder builder_(_fbb);
  builder_.add_center(center);
  builder_.add_size(size);
  return builder_.Finish();
}

struct HurtDecisionBox FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::Vector<flatbuffers::Offset<ShapeBox>> *boxs() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ShapeBox>> *>(4); }
  uint8_t hasHit() const { return GetField<uint8_t>(6, 0); }
  uint8_t blockToggle() const { return GetField<uint8_t>(8, 0); }
  float zDim() const { return GetField<float>(10, 0); }
  int32_t damage() const { return GetField<int32_t>(12, 0); }
  int32_t hurtID() const { return GetField<int32_t>(14, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* boxs */) &&
           verifier.Verify(boxs()) &&
           verifier.VerifyVectorOfTables(boxs()) &&
           VerifyField<uint8_t>(verifier, 6 /* hasHit */) &&
           VerifyField<uint8_t>(verifier, 8 /* blockToggle */) &&
           VerifyField<float>(verifier, 10 /* zDim */) &&
           VerifyField<int32_t>(verifier, 12 /* damage */) &&
           VerifyField<int32_t>(verifier, 14 /* hurtID */) &&
           verifier.EndTable();
  }
};

struct HurtDecisionBoxBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_boxs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShapeBox>>> boxs) { fbb_.AddOffset(4, boxs); }
  void add_hasHit(uint8_t hasHit) { fbb_.AddElement<uint8_t>(6, hasHit, 0); }
  void add_blockToggle(uint8_t blockToggle) { fbb_.AddElement<uint8_t>(8, blockToggle, 0); }
  void add_zDim(float zDim) { fbb_.AddElement<float>(10, zDim, 0); }
  void add_damage(int32_t damage) { fbb_.AddElement<int32_t>(12, damage, 0); }
  void add_hurtID(int32_t hurtID) { fbb_.AddElement<int32_t>(14, hurtID, 0); }
  HurtDecisionBoxBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  HurtDecisionBoxBuilder &operator=(const HurtDecisionBoxBuilder &);
  flatbuffers::Offset<HurtDecisionBox> Finish() {
    auto o = flatbuffers::Offset<HurtDecisionBox>(fbb_.EndTable(start_, 6));
    return o;
  }
};

inline flatbuffers::Offset<HurtDecisionBox> CreateHurtDecisionBox(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShapeBox>>> boxs = 0,
   uint8_t hasHit = 0,
   uint8_t blockToggle = 0,
   float zDim = 0,
   int32_t damage = 0,
   int32_t hurtID = 0) {
  HurtDecisionBoxBuilder builder_(_fbb);
  builder_.add_hurtID(hurtID);
  builder_.add_damage(damage);
  builder_.add_zDim(zDim);
  builder_.add_boxs(boxs);
  builder_.add_blockToggle(blockToggle);
  builder_.add_hasHit(hasHit);
  return builder_.Finish();
}

struct DefenceDecisionBox FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::Vector<flatbuffers::Offset<ShapeBox>> *boxs() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ShapeBox>> *>(4); }
  uint8_t hasHit() const { return GetField<uint8_t>(6, 0); }
  uint8_t blockToggle() const { return GetField<uint8_t>(8, 0); }
  int32_t type() const { return GetField<int32_t>(10, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* boxs */) &&
           verifier.Verify(boxs()) &&
           verifier.VerifyVectorOfTables(boxs()) &&
           VerifyField<uint8_t>(verifier, 6 /* hasHit */) &&
           VerifyField<uint8_t>(verifier, 8 /* blockToggle */) &&
           VerifyField<int32_t>(verifier, 10 /* type */) &&
           verifier.EndTable();
  }
};

struct DefenceDecisionBoxBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_boxs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShapeBox>>> boxs) { fbb_.AddOffset(4, boxs); }
  void add_hasHit(uint8_t hasHit) { fbb_.AddElement<uint8_t>(6, hasHit, 0); }
  void add_blockToggle(uint8_t blockToggle) { fbb_.AddElement<uint8_t>(8, blockToggle, 0); }
  void add_type(int32_t type) { fbb_.AddElement<int32_t>(10, type, 0); }
  DefenceDecisionBoxBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DefenceDecisionBoxBuilder &operator=(const DefenceDecisionBoxBuilder &);
  flatbuffers::Offset<DefenceDecisionBox> Finish() {
    auto o = flatbuffers::Offset<DefenceDecisionBox>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<DefenceDecisionBox> CreateDefenceDecisionBox(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShapeBox>>> boxs = 0,
   uint8_t hasHit = 0,
   uint8_t blockToggle = 0,
   int32_t type = 0) {
  DefenceDecisionBoxBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_boxs(boxs);
  builder_.add_blockToggle(blockToggle);
  builder_.add_hasHit(hasHit);
  return builder_.Finish();
}

struct EffectsFrames FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  int32_t startFrames() const { return GetField<int32_t>(6, 0); }
  int32_t endFrames() const { return GetField<int32_t>(8, 0); }
  const flatbuffers::String *attachname() const { return GetPointer<const flatbuffers::String *>(10); }
  int32_t playtype() const { return GetField<int32_t>(12, 0); }
  int32_t timetype() const { return GetField<int32_t>(14, 0); }
  float time() const { return GetField<float>(16, 0); }
  const flatbuffers::String *effectAsset() const { return GetPointer<const flatbuffers::String *>(18); }
  int32_t attachPoint() const { return GetField<int32_t>(20, 0); }
  const Vector3 *localPosition() const { return GetStruct<const Vector3 *>(22); }
  const Quaternion *localRotation() const { return GetStruct<const Quaternion *>(24); }
  const Vector3 *localScale() const { return GetStruct<const Vector3 *>(26); }
  int32_t effecttype() const { return GetField<int32_t>(28, 0); }
  uint8_t loop() const { return GetField<uint8_t>(30, 0); }
  uint8_t loopLoop() const { return GetField<uint8_t>(32, 0); }
  uint8_t onlyLocalSee() const { return GetField<uint8_t>(34, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, 6 /* startFrames */) &&
           VerifyField<int32_t>(verifier, 8 /* endFrames */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* attachname */) &&
           verifier.Verify(attachname()) &&
           VerifyField<int32_t>(verifier, 12 /* playtype */) &&
           VerifyField<int32_t>(verifier, 14 /* timetype */) &&
           VerifyField<float>(verifier, 16 /* time */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 18 /* effectAsset */) &&
           verifier.Verify(effectAsset()) &&
           VerifyField<int32_t>(verifier, 20 /* attachPoint */) &&
           VerifyField<Vector3>(verifier, 22 /* localPosition */) &&
           VerifyField<Quaternion>(verifier, 24 /* localRotation */) &&
           VerifyField<Vector3>(verifier, 26 /* localScale */) &&
           VerifyField<int32_t>(verifier, 28 /* effecttype */) &&
           VerifyField<uint8_t>(verifier, 30 /* loop */) &&
           VerifyField<uint8_t>(verifier, 32 /* loopLoop */) &&
           VerifyField<uint8_t>(verifier, 34 /* onlyLocalSee */) &&
           verifier.EndTable();
  }
};

struct EffectsFramesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_startFrames(int32_t startFrames) { fbb_.AddElement<int32_t>(6, startFrames, 0); }
  void add_endFrames(int32_t endFrames) { fbb_.AddElement<int32_t>(8, endFrames, 0); }
  void add_attachname(flatbuffers::Offset<flatbuffers::String> attachname) { fbb_.AddOffset(10, attachname); }
  void add_playtype(int32_t playtype) { fbb_.AddElement<int32_t>(12, playtype, 0); }
  void add_timetype(int32_t timetype) { fbb_.AddElement<int32_t>(14, timetype, 0); }
  void add_time(float time) { fbb_.AddElement<float>(16, time, 0); }
  void add_effectAsset(flatbuffers::Offset<flatbuffers::String> effectAsset) { fbb_.AddOffset(18, effectAsset); }
  void add_attachPoint(int32_t attachPoint) { fbb_.AddElement<int32_t>(20, attachPoint, 0); }
  void add_localPosition(const Vector3 *localPosition) { fbb_.AddStruct(22, localPosition); }
  void add_localRotation(const Quaternion *localRotation) { fbb_.AddStruct(24, localRotation); }
  void add_localScale(const Vector3 *localScale) { fbb_.AddStruct(26, localScale); }
  void add_effecttype(int32_t effecttype) { fbb_.AddElement<int32_t>(28, effecttype, 0); }
  void add_loop(uint8_t loop) { fbb_.AddElement<uint8_t>(30, loop, 0); }
  void add_loopLoop(uint8_t loopLoop) { fbb_.AddElement<uint8_t>(32, loopLoop, 0); }
  void add_onlyLocalSee(uint8_t onlyLocalSee) { fbb_.AddElement<uint8_t>(34, onlyLocalSee, 0); }
  EffectsFramesBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  EffectsFramesBuilder &operator=(const EffectsFramesBuilder &);
  flatbuffers::Offset<EffectsFrames> Finish() {
    auto o = flatbuffers::Offset<EffectsFrames>(fbb_.EndTable(start_, 16));
    return o;
  }
};

inline flatbuffers::Offset<EffectsFrames> CreateEffectsFrames(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   int32_t startFrames = 0,
   int32_t endFrames = 0,
   flatbuffers::Offset<flatbuffers::String> attachname = 0,
   int32_t playtype = 0,
   int32_t timetype = 0,
   float time = 0,
   flatbuffers::Offset<flatbuffers::String> effectAsset = 0,
   int32_t attachPoint = 0,
   const Vector3 *localPosition = 0,
   const Quaternion *localRotation = 0,
   const Vector3 *localScale = 0,
   int32_t effecttype = 0,
   uint8_t loop = 0,
   uint8_t loopLoop = 0,
   uint8_t onlyLocalSee = 0) {
  EffectsFramesBuilder builder_(_fbb);
  builder_.add_effecttype(effecttype);
  builder_.add_localScale(localScale);
  builder_.add_localRotation(localRotation);
  builder_.add_localPosition(localPosition);
  builder_.add_attachPoint(attachPoint);
  builder_.add_effectAsset(effectAsset);
  builder_.add_time(time);
  builder_.add_timetype(timetype);
  builder_.add_playtype(playtype);
  builder_.add_attachname(attachname);
  builder_.add_endFrames(endFrames);
  builder_.add_startFrames(startFrames);
  builder_.add_name(name);
  builder_.add_onlyLocalSee(onlyLocalSee);
  builder_.add_loopLoop(loopLoop);
  builder_.add_loop(loop);
  return builder_.Finish();
}

struct EntityFrames FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  int32_t resID() const { return GetField<int32_t>(6, 0); }
  int32_t type() const { return GetField<int32_t>(8, 0); }
  uint8_t randomResID() const { return GetField<uint8_t>(10, 0); }
  const flatbuffers::Vector<int32_t> *resIDList() const { return GetPointer<const flatbuffers::Vector<int32_t> *>(12); }
  int32_t startFrames() const { return GetField<int32_t>(14, 0); }
  const flatbuffers::String *entityAsset() const { return GetPointer<const flatbuffers::String *>(16); }
  const Vector2 *gravity() const { return GetStruct<const Vector2 *>(18); }
  float speed() const { return GetField<float>(20, 0); }
  float angle() const { return GetField<float>(22, 0); }
  uint8_t isAngleWithEffect() const { return GetField<uint8_t>(24, 0); }
  const Vector2 *emitposition() const { return GetStruct<const Vector2 *>(26); }
  float emitPositionZ() const { return GetField<float>(28, 0); }
  int32_t axisType() const { return GetField<int32_t>(30, 0); }
  float shockTime() const { return GetField<float>(32, 0); }
  float shockSpeed() const { return GetField<float>(34, 0); }
  float shockRangeX() const { return GetField<float>(36, 0); }
  float shockRangeY() const { return GetField<float>(38, 0); }
  uint8_t isRotation() const { return GetField<uint8_t>(40, 0); }
  float rotateSpeed() const { return GetField<float>(42, 0); }
  float moveSpeed() const { return GetField<float>(44, 0); }
  int32_t rotateInitDegree() const { return GetField<int32_t>(46, 0); }
  const ShockInfo *sceneShock() const { return GetStruct<const ShockInfo *>(48); }
  int32_t hitFallUP() const { return GetField<int32_t>(50, 0); }
  float forceY() const { return GetField<float>(52, 0); }
  int32_t hurtID() const { return GetField<int32_t>(54, 0); }
  float lifeTime() const { return GetField<float>(56, 0); }
  uint8_t hitThrough() const { return GetField<uint8_t>(58, 0); }
  int32_t hitCount() const { return GetField<int32_t>(60, 0); }
  float distance() const { return GetField<float>(62, 0); }
  uint8_t attackCountExceedPlayExtDead() const { return GetField<uint8_t>(64, 0); }
  uint8_t hitGroundClick() const { return GetField<uint8_t>(66, 0); }
  float delayDead() const { return GetField<float>(68, 0); }
  int32_t offsetType() const { return GetField<int32_t>(70, 0); }
  int32_t targetChooseType() const { return GetField<int32_t>(72, 0); }
  const Vector2 *range() const { return GetStruct<const Vector2 *>(74); }
  float boomerangeDistance() const { return GetField<float>(76, 0); }
  float stayDuration() const { return GetField<float>(78, 0); }
  float paraSpeed() const { return GetField<float>(80, 0); }
  float paraGravity() const { return GetField<float>(82, 0); }
  const Vector2 *offset() const { return GetStruct<const Vector2 *>(84); }
  uint8_t useRandomLaunch() const { return GetField<uint8_t>(86, 0); }
  const RandomLaunchInfo *randomLaunchInfo() const { return GetStruct<const RandomLaunchInfo *>(88); }
  uint8_t onCollideDie() const { return GetField<uint8_t>(90, 0); }
  uint8_t onXInBlockDie() const { return GetField<uint8_t>(92, 0); }
  uint8_t changeForceBehindOther() const { return GetField<uint8_t>(94, 0); }
  int32_t changeFace() const { return GetField<int32_t>(96, 0); }
  float changeMaxAngle() const { return GetField<float>(98, 0); }
  float chaseTime() const { return GetField<float>(100, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, 6 /* resID */) &&
           VerifyField<int32_t>(verifier, 8 /* type */) &&
           VerifyField<uint8_t>(verifier, 10 /* randomResID */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 12 /* resIDList */) &&
           verifier.Verify(resIDList()) &&
           VerifyField<int32_t>(verifier, 14 /* startFrames */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 16 /* entityAsset */) &&
           verifier.Verify(entityAsset()) &&
           VerifyField<Vector2>(verifier, 18 /* gravity */) &&
           VerifyField<float>(verifier, 20 /* speed */) &&
           VerifyField<float>(verifier, 22 /* angle */) &&
           VerifyField<uint8_t>(verifier, 24 /* isAngleWithEffect */) &&
           VerifyField<Vector2>(verifier, 26 /* emitposition */) &&
           VerifyField<float>(verifier, 28 /* emitPositionZ */) &&
           VerifyField<int32_t>(verifier, 30 /* axisType */) &&
           VerifyField<float>(verifier, 32 /* shockTime */) &&
           VerifyField<float>(verifier, 34 /* shockSpeed */) &&
           VerifyField<float>(verifier, 36 /* shockRangeX */) &&
           VerifyField<float>(verifier, 38 /* shockRangeY */) &&
           VerifyField<uint8_t>(verifier, 40 /* isRotation */) &&
           VerifyField<float>(verifier, 42 /* rotateSpeed */) &&
           VerifyField<float>(verifier, 44 /* moveSpeed */) &&
           VerifyField<int32_t>(verifier, 46 /* rotateInitDegree */) &&
           VerifyField<ShockInfo>(verifier, 48 /* sceneShock */) &&
           VerifyField<int32_t>(verifier, 50 /* hitFallUP */) &&
           VerifyField<float>(verifier, 52 /* forceY */) &&
           VerifyField<int32_t>(verifier, 54 /* hurtID */) &&
           VerifyField<float>(verifier, 56 /* lifeTime */) &&
           VerifyField<uint8_t>(verifier, 58 /* hitThrough */) &&
           VerifyField<int32_t>(verifier, 60 /* hitCount */) &&
           VerifyField<float>(verifier, 62 /* distance */) &&
           VerifyField<uint8_t>(verifier, 64 /* attackCountExceedPlayExtDead */) &&
           VerifyField<uint8_t>(verifier, 66 /* hitGroundClick */) &&
           VerifyField<float>(verifier, 68 /* delayDead */) &&
           VerifyField<int32_t>(verifier, 70 /* offsetType */) &&
           VerifyField<int32_t>(verifier, 72 /* targetChooseType */) &&
           VerifyField<Vector2>(verifier, 74 /* range */) &&
           VerifyField<float>(verifier, 76 /* boomerangeDistance */) &&
           VerifyField<float>(verifier, 78 /* stayDuration */) &&
           VerifyField<float>(verifier, 80 /* paraSpeed */) &&
           VerifyField<float>(verifier, 82 /* paraGravity */) &&
           VerifyField<Vector2>(verifier, 84 /* offset */) &&
           VerifyField<uint8_t>(verifier, 86 /* useRandomLaunch */) &&
           VerifyField<RandomLaunchInfo>(verifier, 88 /* randomLaunchInfo */) &&
           VerifyField<uint8_t>(verifier, 90 /* onCollideDie */) &&
           VerifyField<uint8_t>(verifier, 92 /* onXInBlockDie */) &&
           VerifyField<uint8_t>(verifier, 94 /* changeForceBehindOther */) &&
           VerifyField<int32_t>(verifier, 96 /* changeFace */) &&
           VerifyField<float>(verifier, 98 /* changeMaxAngle */) &&
           VerifyField<float>(verifier, 100 /* chaseTime */) &&
           verifier.EndTable();
  }
};

struct EntityFramesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_resID(int32_t resID) { fbb_.AddElement<int32_t>(6, resID, 0); }
  void add_type(int32_t type) { fbb_.AddElement<int32_t>(8, type, 0); }
  void add_randomResID(uint8_t randomResID) { fbb_.AddElement<uint8_t>(10, randomResID, 0); }
  void add_resIDList(flatbuffers::Offset<flatbuffers::Vector<int32_t>> resIDList) { fbb_.AddOffset(12, resIDList); }
  void add_startFrames(int32_t startFrames) { fbb_.AddElement<int32_t>(14, startFrames, 0); }
  void add_entityAsset(flatbuffers::Offset<flatbuffers::String> entityAsset) { fbb_.AddOffset(16, entityAsset); }
  void add_gravity(const Vector2 *gravity) { fbb_.AddStruct(18, gravity); }
  void add_speed(float speed) { fbb_.AddElement<float>(20, speed, 0); }
  void add_angle(float angle) { fbb_.AddElement<float>(22, angle, 0); }
  void add_isAngleWithEffect(uint8_t isAngleWithEffect) { fbb_.AddElement<uint8_t>(24, isAngleWithEffect, 0); }
  void add_emitposition(const Vector2 *emitposition) { fbb_.AddStruct(26, emitposition); }
  void add_emitPositionZ(float emitPositionZ) { fbb_.AddElement<float>(28, emitPositionZ, 0); }
  void add_axisType(int32_t axisType) { fbb_.AddElement<int32_t>(30, axisType, 0); }
  void add_shockTime(float shockTime) { fbb_.AddElement<float>(32, shockTime, 0); }
  void add_shockSpeed(float shockSpeed) { fbb_.AddElement<float>(34, shockSpeed, 0); }
  void add_shockRangeX(float shockRangeX) { fbb_.AddElement<float>(36, shockRangeX, 0); }
  void add_shockRangeY(float shockRangeY) { fbb_.AddElement<float>(38, shockRangeY, 0); }
  void add_isRotation(uint8_t isRotation) { fbb_.AddElement<uint8_t>(40, isRotation, 0); }
  void add_rotateSpeed(float rotateSpeed) { fbb_.AddElement<float>(42, rotateSpeed, 0); }
  void add_moveSpeed(float moveSpeed) { fbb_.AddElement<float>(44, moveSpeed, 0); }
  void add_rotateInitDegree(int32_t rotateInitDegree) { fbb_.AddElement<int32_t>(46, rotateInitDegree, 0); }
  void add_sceneShock(const ShockInfo *sceneShock) { fbb_.AddStruct(48, sceneShock); }
  void add_hitFallUP(int32_t hitFallUP) { fbb_.AddElement<int32_t>(50, hitFallUP, 0); }
  void add_forceY(float forceY) { fbb_.AddElement<float>(52, forceY, 0); }
  void add_hurtID(int32_t hurtID) { fbb_.AddElement<int32_t>(54, hurtID, 0); }
  void add_lifeTime(float lifeTime) { fbb_.AddElement<float>(56, lifeTime, 0); }
  void add_hitThrough(uint8_t hitThrough) { fbb_.AddElement<uint8_t>(58, hitThrough, 0); }
  void add_hitCount(int32_t hitCount) { fbb_.AddElement<int32_t>(60, hitCount, 0); }
  void add_distance(float distance) { fbb_.AddElement<float>(62, distance, 0); }
  void add_attackCountExceedPlayExtDead(uint8_t attackCountExceedPlayExtDead) { fbb_.AddElement<uint8_t>(64, attackCountExceedPlayExtDead, 0); }
  void add_hitGroundClick(uint8_t hitGroundClick) { fbb_.AddElement<uint8_t>(66, hitGroundClick, 0); }
  void add_delayDead(float delayDead) { fbb_.AddElement<float>(68, delayDead, 0); }
  void add_offsetType(int32_t offsetType) { fbb_.AddElement<int32_t>(70, offsetType, 0); }
  void add_targetChooseType(int32_t targetChooseType) { fbb_.AddElement<int32_t>(72, targetChooseType, 0); }
  void add_range(const Vector2 *range) { fbb_.AddStruct(74, range); }
  void add_boomerangeDistance(float boomerangeDistance) { fbb_.AddElement<float>(76, boomerangeDistance, 0); }
  void add_stayDuration(float stayDuration) { fbb_.AddElement<float>(78, stayDuration, 0); }
  void add_paraSpeed(float paraSpeed) { fbb_.AddElement<float>(80, paraSpeed, 0); }
  void add_paraGravity(float paraGravity) { fbb_.AddElement<float>(82, paraGravity, 0); }
  void add_offset(const Vector2 *offset) { fbb_.AddStruct(84, offset); }
  void add_useRandomLaunch(uint8_t useRandomLaunch) { fbb_.AddElement<uint8_t>(86, useRandomLaunch, 0); }
  void add_randomLaunchInfo(const RandomLaunchInfo *randomLaunchInfo) { fbb_.AddStruct(88, randomLaunchInfo); }
  void add_onCollideDie(uint8_t onCollideDie) { fbb_.AddElement<uint8_t>(90, onCollideDie, 0); }
  void add_onXInBlockDie(uint8_t onXInBlockDie) { fbb_.AddElement<uint8_t>(92, onXInBlockDie, 0); }
  void add_changeForceBehindOther(uint8_t changeForceBehindOther) { fbb_.AddElement<uint8_t>(94, changeForceBehindOther, 0); }
  void add_changeFace(int32_t changeFace) { fbb_.AddElement<int32_t>(96, changeFace, 0); }
  void add_changeMaxAngle(float changeMaxAngle) { fbb_.AddElement<float>(98, changeMaxAngle, 0); }
  void add_chaseTime(float chaseTime) { fbb_.AddElement<float>(100, chaseTime, 0); }
  EntityFramesBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  EntityFramesBuilder &operator=(const EntityFramesBuilder &);
  flatbuffers::Offset<EntityFrames> Finish() {
    auto o = flatbuffers::Offset<EntityFrames>(fbb_.EndTable(start_, 49));
    return o;
  }
};

inline flatbuffers::Offset<EntityFrames> CreateEntityFrames(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   int32_t resID = 0,
   int32_t type = 0,
   uint8_t randomResID = 0,
   flatbuffers::Offset<flatbuffers::Vector<int32_t>> resIDList = 0,
   int32_t startFrames = 0,
   flatbuffers::Offset<flatbuffers::String> entityAsset = 0,
   const Vector2 *gravity = 0,
   float speed = 0,
   float angle = 0,
   uint8_t isAngleWithEffect = 0,
   const Vector2 *emitposition = 0,
   float emitPositionZ = 0,
   int32_t axisType = 0,
   float shockTime = 0,
   float shockSpeed = 0,
   float shockRangeX = 0,
   float shockRangeY = 0,
   uint8_t isRotation = 0,
   float rotateSpeed = 0,
   float moveSpeed = 0,
   int32_t rotateInitDegree = 0,
   const ShockInfo *sceneShock = 0,
   int32_t hitFallUP = 0,
   float forceY = 0,
   int32_t hurtID = 0,
   float lifeTime = 0,
   uint8_t hitThrough = 0,
   int32_t hitCount = 0,
   float distance = 0,
   uint8_t attackCountExceedPlayExtDead = 0,
   uint8_t hitGroundClick = 0,
   float delayDead = 0,
   int32_t offsetType = 0,
   int32_t targetChooseType = 0,
   const Vector2 *range = 0,
   float boomerangeDistance = 0,
   float stayDuration = 0,
   float paraSpeed = 0,
   float paraGravity = 0,
   const Vector2 *offset = 0,
   uint8_t useRandomLaunch = 0,
   const RandomLaunchInfo *randomLaunchInfo = 0,
   uint8_t onCollideDie = 0,
   uint8_t onXInBlockDie = 0,
   uint8_t changeForceBehindOther = 0,
   int32_t changeFace = 0,
   float changeMaxAngle = 0,
   float chaseTime = 0) {
  EntityFramesBuilder builder_(_fbb);
  builder_.add_chaseTime(chaseTime);
  builder_.add_changeMaxAngle(changeMaxAngle);
  builder_.add_changeFace(changeFace);
  builder_.add_randomLaunchInfo(randomLaunchInfo);
  builder_.add_offset(offset);
  builder_.add_paraGravity(paraGravity);
  builder_.add_paraSpeed(paraSpeed);
  builder_.add_stayDuration(stayDuration);
  builder_.add_boomerangeDistance(boomerangeDistance);
  builder_.add_range(range);
  builder_.add_targetChooseType(targetChooseType);
  builder_.add_offsetType(offsetType);
  builder_.add_delayDead(delayDead);
  builder_.add_distance(distance);
  builder_.add_hitCount(hitCount);
  builder_.add_lifeTime(lifeTime);
  builder_.add_hurtID(hurtID);
  builder_.add_forceY(forceY);
  builder_.add_hitFallUP(hitFallUP);
  builder_.add_sceneShock(sceneShock);
  builder_.add_rotateInitDegree(rotateInitDegree);
  builder_.add_moveSpeed(moveSpeed);
  builder_.add_rotateSpeed(rotateSpeed);
  builder_.add_shockRangeY(shockRangeY);
  builder_.add_shockRangeX(shockRangeX);
  builder_.add_shockSpeed(shockSpeed);
  builder_.add_shockTime(shockTime);
  builder_.add_axisType(axisType);
  builder_.add_emitPositionZ(emitPositionZ);
  builder_.add_emitposition(emitposition);
  builder_.add_angle(angle);
  builder_.add_speed(speed);
  builder_.add_gravity(gravity);
  builder_.add_entityAsset(entityAsset);
  builder_.add_startFrames(startFrames);
  builder_.add_resIDList(resIDList);
  builder_.add_type(type);
  builder_.add_resID(resID);
  builder_.add_name(name);
  builder_.add_changeForceBehindOther(changeForceBehindOther);
  builder_.add_onXInBlockDie(onXInBlockDie);
  builder_.add_onCollideDie(onCollideDie);
  builder_.add_useRandomLaunch(useRandomLaunch);
  builder_.add_hitGroundClick(hitGroundClick);
  builder_.add_attackCountExceedPlayExtDead(attackCountExceedPlayExtDead);
  builder_.add_hitThrough(hitThrough);
  builder_.add_isRotation(isRotation);
  builder_.add_isAngleWithEffect(isAngleWithEffect);
  builder_.add_randomResID(randomResID);
  return builder_.Finish();
}

struct AnimationFrames FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  float start() const { return GetField<float>(4, 0); }
  const flatbuffers::String *anim() const { return GetPointer<const flatbuffers::String *>(6); }
  float blend() const { return GetField<float>(8, 0); }
  int32_t mode() const { return GetField<int32_t>(10, 0); }
  float speed() const { return GetField<float>(12, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, 4 /* start */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* anim */) &&
           verifier.Verify(anim()) &&
           VerifyField<float>(verifier, 8 /* blend */) &&
           VerifyField<int32_t>(verifier, 10 /* mode */) &&
           VerifyField<float>(verifier, 12 /* speed */) &&
           verifier.EndTable();
  }
};

struct AnimationFramesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_start(float start) { fbb_.AddElement<float>(4, start, 0); }
  void add_anim(flatbuffers::Offset<flatbuffers::String> anim) { fbb_.AddOffset(6, anim); }
  void add_blend(float blend) { fbb_.AddElement<float>(8, blend, 0); }
  void add_mode(int32_t mode) { fbb_.AddElement<int32_t>(10, mode, 0); }
  void add_speed(float speed) { fbb_.AddElement<float>(12, speed, 0); }
  AnimationFramesBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimationFramesBuilder &operator=(const AnimationFramesBuilder &);
  flatbuffers::Offset<AnimationFrames> Finish() {
    auto o = flatbuffers::Offset<AnimationFrames>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<AnimationFrames> CreateAnimationFrames(flatbuffers::FlatBufferBuilder &_fbb,
   float start = 0,
   flatbuffers::Offset<flatbuffers::String> anim = 0,
   float blend = 0,
   int32_t mode = 0,
   float speed = 0) {
  AnimationFramesBuilder builder_(_fbb);
  builder_.add_speed(speed);
  builder_.add_mode(mode);
  builder_.add_blend(blend);
  builder_.add_anim(anim);
  builder_.add_start(start);
  return builder_.Finish();
}

struct EntityAttachFrames FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  int32_t resID() const { return GetField<int32_t>(6, 0); }
  float start() const { return GetField<float>(8, 0); }
  float end() const { return GetField<float>(10, 0); }
  const flatbuffers::String *attachName() const { return GetPointer<const flatbuffers::String *>(12); }
  const flatbuffers::String *entityAsset() const { return GetPointer<const flatbuffers::String *>(14); }
  const TransformParam *trans() const { return GetStruct<const TransformParam *>(16); }
  const flatbuffers::Vector<flatbuffers::Offset<AnimationFrames>> *animations() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimationFrames>> *>(18); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, 6 /* resID */) &&
           VerifyField<float>(verifier, 8 /* start */) &&
           VerifyField<float>(verifier, 10 /* end */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 12 /* attachName */) &&
           verifier.Verify(attachName()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 14 /* entityAsset */) &&
           verifier.Verify(entityAsset()) &&
           VerifyField<TransformParam>(verifier, 16 /* trans */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 18 /* animations */) &&
           verifier.Verify(animations()) &&
           verifier.VerifyVectorOfTables(animations()) &&
           verifier.EndTable();
  }
};

struct EntityAttachFramesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_resID(int32_t resID) { fbb_.AddElement<int32_t>(6, resID, 0); }
  void add_start(float start) { fbb_.AddElement<float>(8, start, 0); }
  void add_end(float end) { fbb_.AddElement<float>(10, end, 0); }
  void add_attachName(flatbuffers::Offset<flatbuffers::String> attachName) { fbb_.AddOffset(12, attachName); }
  void add_entityAsset(flatbuffers::Offset<flatbuffers::String> entityAsset) { fbb_.AddOffset(14, entityAsset); }
  void add_trans(const TransformParam *trans) { fbb_.AddStruct(16, trans); }
  void add_animations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationFrames>>> animations) { fbb_.AddOffset(18, animations); }
  EntityAttachFramesBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  EntityAttachFramesBuilder &operator=(const EntityAttachFramesBuilder &);
  flatbuffers::Offset<EntityAttachFrames> Finish() {
    auto o = flatbuffers::Offset<EntityAttachFrames>(fbb_.EndTable(start_, 8));
    return o;
  }
};

inline flatbuffers::Offset<EntityAttachFrames> CreateEntityAttachFrames(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   int32_t resID = 0,
   float start = 0,
   float end = 0,
   flatbuffers::Offset<flatbuffers::String> attachName = 0,
   flatbuffers::Offset<flatbuffers::String> entityAsset = 0,
   const TransformParam *trans = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationFrames>>> animations = 0) {
  EntityAttachFramesBuilder builder_(_fbb);
  builder_.add_animations(animations);
  builder_.add_trans(trans);
  builder_.add_entityAsset(entityAsset);
  builder_.add_attachName(attachName);
  builder_.add_end(end);
  builder_.add_start(start);
  builder_.add_resID(resID);
  builder_.add_name(name);
  return builder_.Finish();
}

struct ChargeConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  int32_t repeatPhase() const { return GetField<int32_t>(4, 0); }
  int32_t changePhase() const { return GetField<int32_t>(6, 0); }
  int32_t switchPhaseID() const { return GetField<int32_t>(8, 0); }
  float chargeDuration() const { return GetField<float>(10, 0); }
  float chargeMinDuration() const { return GetField<float>(12, 0); }
  const flatbuffers::String *effect() const { return GetPointer<const flatbuffers::String *>(14); }
  const flatbuffers::String *locator() const { return GetPointer<const flatbuffers::String *>(16); }
  int32_t buffInfo() const { return GetField<int32_t>(18, 0); }
  uint8_t playBuffAni() const { return GetField<uint8_t>(20, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4 /* repeatPhase */) &&
           VerifyField<int32_t>(verifier, 6 /* changePhase */) &&
           VerifyField<int32_t>(verifier, 8 /* switchPhaseID */) &&
           VerifyField<float>(verifier, 10 /* chargeDuration */) &&
           VerifyField<float>(verifier, 12 /* chargeMinDuration */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 14 /* effect */) &&
           verifier.Verify(effect()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 16 /* locator */) &&
           verifier.Verify(locator()) &&
           VerifyField<int32_t>(verifier, 18 /* buffInfo */) &&
           VerifyField<uint8_t>(verifier, 20 /* playBuffAni */) &&
           verifier.EndTable();
  }
};

struct ChargeConfigBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_repeatPhase(int32_t repeatPhase) { fbb_.AddElement<int32_t>(4, repeatPhase, 0); }
  void add_changePhase(int32_t changePhase) { fbb_.AddElement<int32_t>(6, changePhase, 0); }
  void add_switchPhaseID(int32_t switchPhaseID) { fbb_.AddElement<int32_t>(8, switchPhaseID, 0); }
  void add_chargeDuration(float chargeDuration) { fbb_.AddElement<float>(10, chargeDuration, 0); }
  void add_chargeMinDuration(float chargeMinDuration) { fbb_.AddElement<float>(12, chargeMinDuration, 0); }
  void add_effect(flatbuffers::Offset<flatbuffers::String> effect) { fbb_.AddOffset(14, effect); }
  void add_locator(flatbuffers::Offset<flatbuffers::String> locator) { fbb_.AddOffset(16, locator); }
  void add_buffInfo(int32_t buffInfo) { fbb_.AddElement<int32_t>(18, buffInfo, 0); }
  void add_playBuffAni(uint8_t playBuffAni) { fbb_.AddElement<uint8_t>(20, playBuffAni, 0); }
  ChargeConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ChargeConfigBuilder &operator=(const ChargeConfigBuilder &);
  flatbuffers::Offset<ChargeConfig> Finish() {
    auto o = flatbuffers::Offset<ChargeConfig>(fbb_.EndTable(start_, 9));
    return o;
  }
};

inline flatbuffers::Offset<ChargeConfig> CreateChargeConfig(flatbuffers::FlatBufferBuilder &_fbb,
   int32_t repeatPhase = 0,
   int32_t changePhase = 0,
   int32_t switchPhaseID = 0,
   float chargeDuration = 0,
   float chargeMinDuration = 0,
   flatbuffers::Offset<flatbuffers::String> effect = 0,
   flatbuffers::Offset<flatbuffers::String> locator = 0,
   int32_t buffInfo = 0,
   uint8_t playBuffAni = 0) {
  ChargeConfigBuilder builder_(_fbb);
  builder_.add_buffInfo(buffInfo);
  builder_.add_locator(locator);
  builder_.add_effect(effect);
  builder_.add_chargeMinDuration(chargeMinDuration);
  builder_.add_chargeDuration(chargeDuration);
  builder_.add_switchPhaseID(switchPhaseID);
  builder_.add_changePhase(changePhase);
  builder_.add_repeatPhase(repeatPhase);
  builder_.add_playBuffAni(playBuffAni);
  return builder_.Finish();
}

struct OperationConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  int32_t changePhase() const { return GetField<int32_t>(4, 0); }
  const flatbuffers::Vector<int32_t> *changeSkillIDs() const { return GetPointer<const flatbuffers::Vector<int32_t> *>(6); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4 /* changePhase */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* changeSkillIDs */) &&
           verifier.Verify(changeSkillIDs()) &&
           verifier.EndTable();
  }
};

struct OperationConfigBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_changePhase(int32_t changePhase) { fbb_.AddElement<int32_t>(4, changePhase, 0); }
  void add_changeSkillIDs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> changeSkillIDs) { fbb_.AddOffset(6, changeSkillIDs); }
  OperationConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  OperationConfigBuilder &operator=(const OperationConfigBuilder &);
  flatbuffers::Offset<OperationConfig> Finish() {
    auto o = flatbuffers::Offset<OperationConfig>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<OperationConfig> CreateOperationConfig(flatbuffers::FlatBufferBuilder &_fbb,
   int32_t changePhase = 0,
   flatbuffers::Offset<flatbuffers::Vector<int32_t>> changeSkillIDs = 0) {
  OperationConfigBuilder builder_(_fbb);
  builder_.add_changeSkillIDs(changeSkillIDs);
  builder_.add_changePhase(changePhase);
  return builder_.Finish();
}

struct SkillJoystickConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  int32_t mode() const { return GetField<int32_t>(4, 0); }
  uint8_t notDisplayLineEffect() const { return GetField<uint8_t>(6, 0); }
  uint8_t dontRemoveJoystick() const { return GetField<uint8_t>(8, 0); }
  const flatbuffers::String *effectName() const { return GetPointer<const flatbuffers::String *>(10); }
  int32_t effectMoveRadius() const { return GetField<int32_t>(12, 0); }
  const Vector3 *effectMoveSpeed() const { return GetStruct<const Vector3 *>(14); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4 /* mode */) &&
           VerifyField<uint8_t>(verifier, 6 /* notDisplayLineEffect */) &&
           VerifyField<uint8_t>(verifier, 8 /* dontRemoveJoystick */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* effectName */) &&
           verifier.Verify(effectName()) &&
           VerifyField<int32_t>(verifier, 12 /* effectMoveRadius */) &&
           VerifyField<Vector3>(verifier, 14 /* effectMoveSpeed */) &&
           verifier.EndTable();
  }
};

struct SkillJoystickConfigBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mode(int32_t mode) { fbb_.AddElement<int32_t>(4, mode, 0); }
  void add_notDisplayLineEffect(uint8_t notDisplayLineEffect) { fbb_.AddElement<uint8_t>(6, notDisplayLineEffect, 0); }
  void add_dontRemoveJoystick(uint8_t dontRemoveJoystick) { fbb_.AddElement<uint8_t>(8, dontRemoveJoystick, 0); }
  void add_effectName(flatbuffers::Offset<flatbuffers::String> effectName) { fbb_.AddOffset(10, effectName); }
  void add_effectMoveRadius(int32_t effectMoveRadius) { fbb_.AddElement<int32_t>(12, effectMoveRadius, 0); }
  void add_effectMoveSpeed(const Vector3 *effectMoveSpeed) { fbb_.AddStruct(14, effectMoveSpeed); }
  SkillJoystickConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SkillJoystickConfigBuilder &operator=(const SkillJoystickConfigBuilder &);
  flatbuffers::Offset<SkillJoystickConfig> Finish() {
    auto o = flatbuffers::Offset<SkillJoystickConfig>(fbb_.EndTable(start_, 6));
    return o;
  }
};

inline flatbuffers::Offset<SkillJoystickConfig> CreateSkillJoystickConfig(flatbuffers::FlatBufferBuilder &_fbb,
   int32_t mode = 0,
   uint8_t notDisplayLineEffect = 0,
   uint8_t dontRemoveJoystick = 0,
   flatbuffers::Offset<flatbuffers::String> effectName = 0,
   int32_t effectMoveRadius = 0,
   const Vector3 *effectMoveSpeed = 0) {
  SkillJoystickConfigBuilder builder_(_fbb);
  builder_.add_effectMoveSpeed(effectMoveSpeed);
  builder_.add_effectMoveRadius(effectMoveRadius);
  builder_.add_effectName(effectName);
  builder_.add_mode(mode);
  builder_.add_dontRemoveJoystick(dontRemoveJoystick);
  builder_.add_notDisplayLineEffect(notDisplayLineEffect);
  return builder_.Finish();
}

struct SkillEvent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  int32_t eventType() const { return GetField<int32_t>(4, 0); }
  int32_t eventAction() const { return GetField<int32_t>(6, 0); }
  const flatbuffers::String *paramter() const { return GetPointer<const flatbuffers::String *>(8); }
  int32_t workPhase() const { return GetField<int32_t>(10, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4 /* eventType */) &&
           VerifyField<int32_t>(verifier, 6 /* eventAction */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* paramter */) &&
           verifier.Verify(paramter()) &&
           VerifyField<int32_t>(verifier, 10 /* workPhase */) &&
           verifier.EndTable();
  }
};

struct SkillEventBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eventType(int32_t eventType) { fbb_.AddElement<int32_t>(4, eventType, 0); }
  void add_eventAction(int32_t eventAction) { fbb_.AddElement<int32_t>(6, eventAction, 0); }
  void add_paramter(flatbuffers::Offset<flatbuffers::String> paramter) { fbb_.AddOffset(8, paramter); }
  void add_workPhase(int32_t workPhase) { fbb_.AddElement<int32_t>(10, workPhase, 0); }
  SkillEventBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SkillEventBuilder &operator=(const SkillEventBuilder &);
  flatbuffers::Offset<SkillEvent> Finish() {
    auto o = flatbuffers::Offset<SkillEvent>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<SkillEvent> CreateSkillEvent(flatbuffers::FlatBufferBuilder &_fbb,
   int32_t eventType = 0,
   int32_t eventAction = 0,
   flatbuffers::Offset<flatbuffers::String> paramter = 0,
   int32_t workPhase = 0) {
  SkillEventBuilder builder_(_fbb);
  builder_.add_workPhase(workPhase);
  builder_.add_paramter(paramter);
  builder_.add_eventAction(eventAction);
  builder_.add_eventType(eventType);
  return builder_.Finish();
}

struct boolValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  uint8_t value() const { return GetField<uint8_t>(4, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, 4 /* value */) &&
           verifier.EndTable();
  }
};

struct boolValueBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint8_t value) { fbb_.AddElement<uint8_t>(4, value, 0); }
  boolValueBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  boolValueBuilder &operator=(const boolValueBuilder &);
  flatbuffers::Offset<boolValue> Finish() {
    auto o = flatbuffers::Offset<boolValue>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<boolValue> CreateboolValue(flatbuffers::FlatBufferBuilder &_fbb,
   uint8_t value = 0) {
  boolValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct floatValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  float value() const { return GetField<float>(4, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, 4 /* value */) &&
           verifier.EndTable();
  }
};

struct floatValueBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(float value) { fbb_.AddElement<float>(4, value, 0); }
  floatValueBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  floatValueBuilder &operator=(const floatValueBuilder &);
  flatbuffers::Offset<floatValue> Finish() {
    auto o = flatbuffers::Offset<floatValue>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<floatValue> CreatefloatValue(flatbuffers::FlatBufferBuilder &_fbb,
   float value = 0) {
  floatValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct intValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  int32_t value() const { return GetField<int32_t>(4, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4 /* value */) &&
           verifier.EndTable();
  }
};

struct intValueBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int32_t value) { fbb_.AddElement<int32_t>(4, value, 0); }
  intValueBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  intValueBuilder &operator=(const intValueBuilder &);
  flatbuffers::Offset<intValue> Finish() {
    auto o = flatbuffers::Offset<intValue>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<intValue> CreateintValue(flatbuffers::FlatBufferBuilder &_fbb,
   int32_t value = 0) {
  intValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct QuaternionValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const Quaternion *value() const { return GetStruct<const Quaternion *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Quaternion>(verifier, 4 /* value */) &&
           verifier.EndTable();
  }
};

struct QuaternionValueBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(const Quaternion *value) { fbb_.AddStruct(4, value); }
  QuaternionValueBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  QuaternionValueBuilder &operator=(const QuaternionValueBuilder &);
  flatbuffers::Offset<QuaternionValue> Finish() {
    auto o = flatbuffers::Offset<QuaternionValue>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<QuaternionValue> CreateQuaternionValue(flatbuffers::FlatBufferBuilder &_fbb,
   const Quaternion *value = 0) {
  QuaternionValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct uintValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  uint32_t value() const { return GetField<uint32_t>(4, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, 4 /* value */) &&
           verifier.EndTable();
  }
};

struct uintValueBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint32_t value) { fbb_.AddElement<uint32_t>(4, value, 0); }
  uintValueBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  uintValueBuilder &operator=(const uintValueBuilder &);
  flatbuffers::Offset<uintValue> Finish() {
    auto o = flatbuffers::Offset<uintValue>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<uintValue> CreateuintValue(flatbuffers::FlatBufferBuilder &_fbb,
   uint32_t value = 0) {
  uintValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Vector3Value FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const Vector3 *value() const { return GetStruct<const Vector3 *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vector3>(verifier, 4 /* value */) &&
           verifier.EndTable();
  }
};

struct Vector3ValueBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(const Vector3 *value) { fbb_.AddStruct(4, value); }
  Vector3ValueBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  Vector3ValueBuilder &operator=(const Vector3ValueBuilder &);
  flatbuffers::Offset<Vector3Value> Finish() {
    auto o = flatbuffers::Offset<Vector3Value>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<Vector3Value> CreateVector3Value(flatbuffers::FlatBufferBuilder &_fbb,
   const Vector3 *value = 0) {
  Vector3ValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct DSkillPropertyModify FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  int32_t startframe() const { return GetField<int32_t>(6, 0); }
  int32_t length() const { return GetField<int32_t>(8, 0); }
  int32_t tag() const { return GetField<int32_t>(10, 0); }
  int32_t modifyfliter() const { return GetField<int32_t>(12, 0); }
  float value() const { return GetField<float>(14, 0); }
  float movedValue() const { return GetField<float>(16, 0); }
  WeaponClassesOrWhatever svalue_type() const { return static_cast<WeaponClassesOrWhatever>(GetField<uint8_t>(18, 0)); }
  const void *svalue() const { return GetPointer<const void *>(20); }
  uint8_t jumpToTargetPos() const { return GetField<uint8_t>(22, 0); }
  uint8_t joystickControl() const { return GetField<uint8_t>(24, 0); }
  float valueAcc() const { return GetField<float>(26, 0); }
  float movedValueAcc() const { return GetField<float>(28, 0); }
  int32_t modifyXBackward() const { return GetField<int32_t>(30, 0); }
  float movedYValue() const { return GetField<float>(32, 0); }
  float movedYValueAcc() const { return GetField<float>(34, 0); }
  uint8_t eachFrameModify() const { return GetField<uint8_t>(36, 0); }
  uint8_t useMovedYValue() const { return GetField<uint8_t>(38, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, 6 /* startframe */) &&
           VerifyField<int32_t>(verifier, 8 /* length */) &&
           VerifyField<int32_t>(verifier, 10 /* tag */) &&
           VerifyField<int32_t>(verifier, 12 /* modifyfliter */) &&
           VerifyField<float>(verifier, 14 /* value */) &&
           VerifyField<float>(verifier, 16 /* movedValue */) &&
           VerifyField<uint8_t>(verifier, 18 /* svalue_type */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 20 /* svalue */) &&
           VerifyWeaponClassesOrWhatever(verifier, svalue(), svalue_type()) &&
           VerifyField<uint8_t>(verifier, 22 /* jumpToTargetPos */) &&
           VerifyField<uint8_t>(verifier, 24 /* joystickControl */) &&
           VerifyField<float>(verifier, 26 /* valueAcc */) &&
           VerifyField<float>(verifier, 28 /* movedValueAcc */) &&
           VerifyField<int32_t>(verifier, 30 /* modifyXBackward */) &&
           VerifyField<float>(verifier, 32 /* movedYValue */) &&
           VerifyField<float>(verifier, 34 /* movedYValueAcc */) &&
           VerifyField<uint8_t>(verifier, 36 /* eachFrameModify */) &&
           VerifyField<uint8_t>(verifier, 38 /* useMovedYValue */) &&
           verifier.EndTable();
  }
};

struct DSkillPropertyModifyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_startframe(int32_t startframe) { fbb_.AddElement<int32_t>(6, startframe, 0); }
  void add_length(int32_t length) { fbb_.AddElement<int32_t>(8, length, 0); }
  void add_tag(int32_t tag) { fbb_.AddElement<int32_t>(10, tag, 0); }
  void add_modifyfliter(int32_t modifyfliter) { fbb_.AddElement<int32_t>(12, modifyfliter, 0); }
  void add_value(float value) { fbb_.AddElement<float>(14, value, 0); }
  void add_movedValue(float movedValue) { fbb_.AddElement<float>(16, movedValue, 0); }
  void add_svalue_type(WeaponClassesOrWhatever svalue_type) { fbb_.AddElement<uint8_t>(18, static_cast<uint8_t>(svalue_type), 0); }
  void add_svalue(flatbuffers::Offset<void> svalue) { fbb_.AddOffset(20, svalue); }
  void add_jumpToTargetPos(uint8_t jumpToTargetPos) { fbb_.AddElement<uint8_t>(22, jumpToTargetPos, 0); }
  void add_joystickControl(uint8_t joystickControl) { fbb_.AddElement<uint8_t>(24, joystickControl, 0); }
  void add_valueAcc(float valueAcc) { fbb_.AddElement<float>(26, valueAcc, 0); }
  void add_movedValueAcc(float movedValueAcc) { fbb_.AddElement<float>(28, movedValueAcc, 0); }
  void add_modifyXBackward(int32_t modifyXBackward) { fbb_.AddElement<int32_t>(30, modifyXBackward, 0); }
  void add_movedYValue(float movedYValue) { fbb_.AddElement<float>(32, movedYValue, 0); }
  void add_movedYValueAcc(float movedYValueAcc) { fbb_.AddElement<float>(34, movedYValueAcc, 0); }
  void add_eachFrameModify(uint8_t eachFrameModify) { fbb_.AddElement<uint8_t>(36, eachFrameModify, 0); }
  void add_useMovedYValue(uint8_t useMovedYValue) { fbb_.AddElement<uint8_t>(38, useMovedYValue, 0); }
  DSkillPropertyModifyBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DSkillPropertyModifyBuilder &operator=(const DSkillPropertyModifyBuilder &);
  flatbuffers::Offset<DSkillPropertyModify> Finish() {
    auto o = flatbuffers::Offset<DSkillPropertyModify>(fbb_.EndTable(start_, 18));
    return o;
  }
};

inline flatbuffers::Offset<DSkillPropertyModify> CreateDSkillPropertyModify(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   int32_t startframe = 0,
   int32_t length = 0,
   int32_t tag = 0,
   int32_t modifyfliter = 0,
   float value = 0,
   float movedValue = 0,
   WeaponClassesOrWhatever svalue_type = WeaponClassesOrWhatever_NONE,
   flatbuffers::Offset<void> svalue = 0,
   uint8_t jumpToTargetPos = 0,
   uint8_t joystickControl = 0,
   float valueAcc = 0,
   float movedValueAcc = 0,
   int32_t modifyXBackward = 0,
   float movedYValue = 0,
   float movedYValueAcc = 0,
   uint8_t eachFrameModify = 0,
   uint8_t useMovedYValue = 0) {
  DSkillPropertyModifyBuilder builder_(_fbb);
  builder_.add_movedYValueAcc(movedYValueAcc);
  builder_.add_movedYValue(movedYValue);
  builder_.add_modifyXBackward(modifyXBackward);
  builder_.add_movedValueAcc(movedValueAcc);
  builder_.add_valueAcc(valueAcc);
  builder_.add_svalue(svalue);
  builder_.add_movedValue(movedValue);
  builder_.add_value(value);
  builder_.add_modifyfliter(modifyfliter);
  builder_.add_tag(tag);
  builder_.add_length(length);
  builder_.add_startframe(startframe);
  builder_.add_name(name);
  builder_.add_useMovedYValue(useMovedYValue);
  builder_.add_eachFrameModify(eachFrameModify);
  builder_.add_joystickControl(joystickControl);
  builder_.add_jumpToTargetPos(jumpToTargetPos);
  builder_.add_svalue_type(svalue_type);
  return builder_.Finish();
}

struct DSkillFrameTag FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  int32_t startframe() const { return GetField<int32_t>(6, 0); }
  int32_t length() const { return GetField<int32_t>(8, 0); }
  int32_t tag() const { return GetField<int32_t>(10, 0); }
  const flatbuffers::String *tagFlag() const { return GetPointer<const flatbuffers::String *>(12); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, 6 /* startframe */) &&
           VerifyField<int32_t>(verifier, 8 /* length */) &&
           VerifyField<int32_t>(verifier, 10 /* tag */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 12 /* tagFlag */) &&
           verifier.Verify(tagFlag()) &&
           verifier.EndTable();
  }
};

struct DSkillFrameTagBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_startframe(int32_t startframe) { fbb_.AddElement<int32_t>(6, startframe, 0); }
  void add_length(int32_t length) { fbb_.AddElement<int32_t>(8, length, 0); }
  void add_tag(int32_t tag) { fbb_.AddElement<int32_t>(10, tag, 0); }
  void add_tagFlag(flatbuffers::Offset<flatbuffers::String> tagFlag) { fbb_.AddOffset(12, tagFlag); }
  DSkillFrameTagBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DSkillFrameTagBuilder &operator=(const DSkillFrameTagBuilder &);
  flatbuffers::Offset<DSkillFrameTag> Finish() {
    auto o = flatbuffers::Offset<DSkillFrameTag>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<DSkillFrameTag> CreateDSkillFrameTag(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   int32_t startframe = 0,
   int32_t length = 0,
   int32_t tag = 0,
   flatbuffers::Offset<flatbuffers::String> tagFlag = 0) {
  DSkillFrameTagBuilder builder_(_fbb);
  builder_.add_tagFlag(tagFlag);
  builder_.add_tag(tag);
  builder_.add_length(length);
  builder_.add_startframe(startframe);
  builder_.add_name(name);
  return builder_.Finish();
}

struct DSkillSfx FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  int32_t startframe() const { return GetField<int32_t>(6, 0); }
  int32_t length() const { return GetField<int32_t>(8, 0); }
  const flatbuffers::String *soundClipAsset() const { return GetPointer<const flatbuffers::String *>(10); }
  uint8_t loop() const { return GetField<uint8_t>(12, 0); }
  int32_t soundID() const { return GetField<int32_t>(14, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, 6 /* startframe */) &&
           VerifyField<int32_t>(verifier, 8 /* length */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* soundClipAsset */) &&
           verifier.Verify(soundClipAsset()) &&
           VerifyField<uint8_t>(verifier, 12 /* loop */) &&
           VerifyField<int32_t>(verifier, 14 /* soundID */) &&
           verifier.EndTable();
  }
};

struct DSkillSfxBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_startframe(int32_t startframe) { fbb_.AddElement<int32_t>(6, startframe, 0); }
  void add_length(int32_t length) { fbb_.AddElement<int32_t>(8, length, 0); }
  void add_soundClipAsset(flatbuffers::Offset<flatbuffers::String> soundClipAsset) { fbb_.AddOffset(10, soundClipAsset); }
  void add_loop(uint8_t loop) { fbb_.AddElement<uint8_t>(12, loop, 0); }
  void add_soundID(int32_t soundID) { fbb_.AddElement<int32_t>(14, soundID, 0); }
  DSkillSfxBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DSkillSfxBuilder &operator=(const DSkillSfxBuilder &);
  flatbuffers::Offset<DSkillSfx> Finish() {
    auto o = flatbuffers::Offset<DSkillSfx>(fbb_.EndTable(start_, 6));
    return o;
  }
};

inline flatbuffers::Offset<DSkillSfx> CreateDSkillSfx(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   int32_t startframe = 0,
   int32_t length = 0,
   flatbuffers::Offset<flatbuffers::String> soundClipAsset = 0,
   uint8_t loop = 0,
   int32_t soundID = 0) {
  DSkillSfxBuilder builder_(_fbb);
  builder_.add_soundID(soundID);
  builder_.add_soundClipAsset(soundClipAsset);
  builder_.add_length(length);
  builder_.add_startframe(startframe);
  builder_.add_name(name);
  builder_.add_loop(loop);
  return builder_.Finish();
}

struct DSkillFrameEffect FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  int32_t startframe() const { return GetField<int32_t>(6, 0); }
  int32_t length() const { return GetField<int32_t>(8, 0); }
  int32_t effectID() const { return GetField<int32_t>(10, 0); }
  float buffTime() const { return GetField<float>(12, 0); }
  uint8_t phaseDelete() const { return GetField<uint8_t>(14, 0); }
  uint8_t finishDelete() const { return GetField<uint8_t>(16, 1); }
  uint8_t finishDeleteAll() const { return GetField<uint8_t>(18, 0); }
  uint8_t useBuffAni() const { return GetField<uint8_t>(20, 1); }
  uint8_t usePause() const { return GetField<uint8_t>(22, 0); }
  float pauseTime() const { return GetField<float>(24, 0); }
  int32_t mechanismId() const { return GetField<int32_t>(26, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, 6 /* startframe */) &&
           VerifyField<int32_t>(verifier, 8 /* length */) &&
           VerifyField<int32_t>(verifier, 10 /* effectID */) &&
           VerifyField<float>(verifier, 12 /* buffTime */) &&
           VerifyField<uint8_t>(verifier, 14 /* phaseDelete */) &&
           VerifyField<uint8_t>(verifier, 16 /* finishDelete */) &&
           VerifyField<uint8_t>(verifier, 18 /* finishDeleteAll */) &&
           VerifyField<uint8_t>(verifier, 20 /* useBuffAni */) &&
           VerifyField<uint8_t>(verifier, 22 /* usePause */) &&
           VerifyField<float>(verifier, 24 /* pauseTime */) &&
           VerifyField<int32_t>(verifier, 26 /* mechanismId */) &&
           verifier.EndTable();
  }
};

struct DSkillFrameEffectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_startframe(int32_t startframe) { fbb_.AddElement<int32_t>(6, startframe, 0); }
  void add_length(int32_t length) { fbb_.AddElement<int32_t>(8, length, 0); }
  void add_effectID(int32_t effectID) { fbb_.AddElement<int32_t>(10, effectID, 0); }
  void add_buffTime(float buffTime) { fbb_.AddElement<float>(12, buffTime, 0); }
  void add_phaseDelete(uint8_t phaseDelete) { fbb_.AddElement<uint8_t>(14, phaseDelete, 0); }
  void add_finishDelete(uint8_t finishDelete) { fbb_.AddElement<uint8_t>(16, finishDelete, 1); }
  void add_finishDeleteAll(uint8_t finishDeleteAll) { fbb_.AddElement<uint8_t>(18, finishDeleteAll, 0); }
  void add_useBuffAni(uint8_t useBuffAni) { fbb_.AddElement<uint8_t>(20, useBuffAni, 1); }
  void add_usePause(uint8_t usePause) { fbb_.AddElement<uint8_t>(22, usePause, 0); }
  void add_pauseTime(float pauseTime) { fbb_.AddElement<float>(24, pauseTime, 0); }
  void add_mechanismId(int32_t mechanismId) { fbb_.AddElement<int32_t>(26, mechanismId, 0); }
  DSkillFrameEffectBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DSkillFrameEffectBuilder &operator=(const DSkillFrameEffectBuilder &);
  flatbuffers::Offset<DSkillFrameEffect> Finish() {
    auto o = flatbuffers::Offset<DSkillFrameEffect>(fbb_.EndTable(start_, 12));
    return o;
  }
};

inline flatbuffers::Offset<DSkillFrameEffect> CreateDSkillFrameEffect(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   int32_t startframe = 0,
   int32_t length = 0,
   int32_t effectID = 0,
   float buffTime = 0,
   uint8_t phaseDelete = 0,
   uint8_t finishDelete = 1,
   uint8_t finishDeleteAll = 0,
   uint8_t useBuffAni = 1,
   uint8_t usePause = 0,
   float pauseTime = 0,
   int32_t mechanismId = 0) {
  DSkillFrameEffectBuilder builder_(_fbb);
  builder_.add_mechanismId(mechanismId);
  builder_.add_pauseTime(pauseTime);
  builder_.add_buffTime(buffTime);
  builder_.add_effectID(effectID);
  builder_.add_length(length);
  builder_.add_startframe(startframe);
  builder_.add_name(name);
  builder_.add_usePause(usePause);
  builder_.add_useBuffAni(useBuffAni);
  builder_.add_finishDeleteAll(finishDeleteAll);
  builder_.add_finishDelete(finishDelete);
  builder_.add_phaseDelete(phaseDelete);
  return builder_.Finish();
}

struct DSkillCameraMove FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  int32_t startframe() const { return GetField<int32_t>(6, 0); }
  int32_t length() const { return GetField<int32_t>(8, 0); }
  float offset() const { return GetField<float>(10, 0); }
  float duraction() const { return GetField<float>(12, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, 6 /* startframe */) &&
           VerifyField<int32_t>(verifier, 8 /* length */) &&
           VerifyField<float>(verifier, 10 /* offset */) &&
           VerifyField<float>(verifier, 12 /* duraction */) &&
           verifier.EndTable();
  }
};

struct DSkillCameraMoveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_startframe(int32_t startframe) { fbb_.AddElement<int32_t>(6, startframe, 0); }
  void add_length(int32_t length) { fbb_.AddElement<int32_t>(8, length, 0); }
  void add_offset(float offset) { fbb_.AddElement<float>(10, offset, 0); }
  void add_duraction(float duraction) { fbb_.AddElement<float>(12, duraction, 0); }
  DSkillCameraMoveBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DSkillCameraMoveBuilder &operator=(const DSkillCameraMoveBuilder &);
  flatbuffers::Offset<DSkillCameraMove> Finish() {
    auto o = flatbuffers::Offset<DSkillCameraMove>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<DSkillCameraMove> CreateDSkillCameraMove(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   int32_t startframe = 0,
   int32_t length = 0,
   float offset = 0,
   float duraction = 0) {
  DSkillCameraMoveBuilder builder_(_fbb);
  builder_.add_duraction(duraction);
  builder_.add_offset(offset);
  builder_.add_length(length);
  builder_.add_startframe(startframe);
  builder_.add_name(name);
  return builder_.Finish();
}

struct DSkillWalkControl FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  int32_t startframe() const { return GetField<int32_t>(6, 0); }
  int32_t length() const { return GetField<int32_t>(8, 0); }
  int32_t walkMode() const { return GetField<int32_t>(10, 0); }
  float walkSpeedPercent() const { return GetField<float>(12, 0); }
  uint8_t useSkillSpeed() const { return GetField<uint8_t>(14, 0); }
  float walkSpeedPercent2() const { return GetField<float>(16, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, 6 /* startframe */) &&
           VerifyField<int32_t>(verifier, 8 /* length */) &&
           VerifyField<int32_t>(verifier, 10 /* walkMode */) &&
           VerifyField<float>(verifier, 12 /* walkSpeedPercent */) &&
           VerifyField<uint8_t>(verifier, 14 /* useSkillSpeed */) &&
           VerifyField<float>(verifier, 16 /* walkSpeedPercent2 */) &&
           verifier.EndTable();
  }
};

struct DSkillWalkControlBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_startframe(int32_t startframe) { fbb_.AddElement<int32_t>(6, startframe, 0); }
  void add_length(int32_t length) { fbb_.AddElement<int32_t>(8, length, 0); }
  void add_walkMode(int32_t walkMode) { fbb_.AddElement<int32_t>(10, walkMode, 0); }
  void add_walkSpeedPercent(float walkSpeedPercent) { fbb_.AddElement<float>(12, walkSpeedPercent, 0); }
  void add_useSkillSpeed(uint8_t useSkillSpeed) { fbb_.AddElement<uint8_t>(14, useSkillSpeed, 0); }
  void add_walkSpeedPercent2(float walkSpeedPercent2) { fbb_.AddElement<float>(16, walkSpeedPercent2, 0); }
  DSkillWalkControlBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DSkillWalkControlBuilder &operator=(const DSkillWalkControlBuilder &);
  flatbuffers::Offset<DSkillWalkControl> Finish() {
    auto o = flatbuffers::Offset<DSkillWalkControl>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<DSkillWalkControl> CreateDSkillWalkControl(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   int32_t startframe = 0,
   int32_t length = 0,
   int32_t walkMode = 0,
   float walkSpeedPercent = 0,
   uint8_t useSkillSpeed = 0,
   float walkSpeedPercent2 = 0) {
  DSkillWalkControlBuilder builder_(_fbb);
  builder_.add_walkSpeedPercent2(walkSpeedPercent2);
  builder_.add_walkSpeedPercent(walkSpeedPercent);
  builder_.add_walkMode(walkMode);
  builder_.add_length(length);
  builder_.add_startframe(startframe);
  builder_.add_name(name);
  builder_.add_useSkillSpeed(useSkillSpeed);
  return builder_.Finish();
}

struct DSkillFrameGrap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  int32_t startframe() const { return GetField<int32_t>(6, 0); }
  int32_t length() const { return GetField<int32_t>(8, 0); }
  int32_t op() const { return GetField<int32_t>(10, 0); }
  uint8_t faceGraber() const { return GetField<uint8_t>(12, 0); }
  const Vector3 *targetPos() const { return GetStruct<const Vector3 *>(14); }
  int32_t targetAction() const { return GetField<int32_t>(16, 0); }
  int32_t targetAngle() const { return GetField<int32_t>(18, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, 6 /* startframe */) &&
           VerifyField<int32_t>(verifier, 8 /* length */) &&
           VerifyField<int32_t>(verifier, 10 /* op */) &&
           VerifyField<uint8_t>(verifier, 12 /* faceGraber */) &&
           VerifyField<Vector3>(verifier, 14 /* targetPos */) &&
           VerifyField<int32_t>(verifier, 16 /* targetAction */) &&
           VerifyField<int32_t>(verifier, 18 /* targetAngle */) &&
           verifier.EndTable();
  }
};

struct DSkillFrameGrapBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_startframe(int32_t startframe) { fbb_.AddElement<int32_t>(6, startframe, 0); }
  void add_length(int32_t length) { fbb_.AddElement<int32_t>(8, length, 0); }
  void add_op(int32_t op) { fbb_.AddElement<int32_t>(10, op, 0); }
  void add_faceGraber(uint8_t faceGraber) { fbb_.AddElement<uint8_t>(12, faceGraber, 0); }
  void add_targetPos(const Vector3 *targetPos) { fbb_.AddStruct(14, targetPos); }
  void add_targetAction(int32_t targetAction) { fbb_.AddElement<int32_t>(16, targetAction, 0); }
  void add_targetAngle(int32_t targetAngle) { fbb_.AddElement<int32_t>(18, targetAngle, 0); }
  DSkillFrameGrapBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DSkillFrameGrapBuilder &operator=(const DSkillFrameGrapBuilder &);
  flatbuffers::Offset<DSkillFrameGrap> Finish() {
    auto o = flatbuffers::Offset<DSkillFrameGrap>(fbb_.EndTable(start_, 8));
    return o;
  }
};

inline flatbuffers::Offset<DSkillFrameGrap> CreateDSkillFrameGrap(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   int32_t startframe = 0,
   int32_t length = 0,
   int32_t op = 0,
   uint8_t faceGraber = 0,
   const Vector3 *targetPos = 0,
   int32_t targetAction = 0,
   int32_t targetAngle = 0) {
  DSkillFrameGrapBuilder builder_(_fbb);
  builder_.add_targetAngle(targetAngle);
  builder_.add_targetAction(targetAction);
  builder_.add_targetPos(targetPos);
  builder_.add_op(op);
  builder_.add_length(length);
  builder_.add_startframe(startframe);
  builder_.add_name(name);
  builder_.add_faceGraber(faceGraber);
  return builder_.Finish();
}

struct DSkillFrameStateOp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  int32_t startframe() const { return GetField<int32_t>(6, 0); }
  int32_t length() const { return GetField<int32_t>(8, 0); }
  int32_t op() const { return GetField<int32_t>(10, 0); }
  int32_t state() const { return GetField<int32_t>(12, 0); }
  int32_t idata1() const { return GetField<int32_t>(14, 0); }
  int32_t idata2() const { return GetField<int32_t>(16, 0); }
  float fdata1() const { return GetField<float>(18, 0); }
  float fdata2() const { return GetField<float>(20, 0); }
  int32_t statetag() const { return GetField<int32_t>(22, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, 6 /* startframe */) &&
           VerifyField<int32_t>(verifier, 8 /* length */) &&
           VerifyField<int32_t>(verifier, 10 /* op */) &&
           VerifyField<int32_t>(verifier, 12 /* state */) &&
           VerifyField<int32_t>(verifier, 14 /* idata1 */) &&
           VerifyField<int32_t>(verifier, 16 /* idata2 */) &&
           VerifyField<float>(verifier, 18 /* fdata1 */) &&
           VerifyField<float>(verifier, 20 /* fdata2 */) &&
           VerifyField<int32_t>(verifier, 22 /* statetag */) &&
           verifier.EndTable();
  }
};

struct DSkillFrameStateOpBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_startframe(int32_t startframe) { fbb_.AddElement<int32_t>(6, startframe, 0); }
  void add_length(int32_t length) { fbb_.AddElement<int32_t>(8, length, 0); }
  void add_op(int32_t op) { fbb_.AddElement<int32_t>(10, op, 0); }
  void add_state(int32_t state) { fbb_.AddElement<int32_t>(12, state, 0); }
  void add_idata1(int32_t idata1) { fbb_.AddElement<int32_t>(14, idata1, 0); }
  void add_idata2(int32_t idata2) { fbb_.AddElement<int32_t>(16, idata2, 0); }
  void add_fdata1(float fdata1) { fbb_.AddElement<float>(18, fdata1, 0); }
  void add_fdata2(float fdata2) { fbb_.AddElement<float>(20, fdata2, 0); }
  void add_statetag(int32_t statetag) { fbb_.AddElement<int32_t>(22, statetag, 0); }
  DSkillFrameStateOpBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DSkillFrameStateOpBuilder &operator=(const DSkillFrameStateOpBuilder &);
  flatbuffers::Offset<DSkillFrameStateOp> Finish() {
    auto o = flatbuffers::Offset<DSkillFrameStateOp>(fbb_.EndTable(start_, 10));
    return o;
  }
};

inline flatbuffers::Offset<DSkillFrameStateOp> CreateDSkillFrameStateOp(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   int32_t startframe = 0,
   int32_t length = 0,
   int32_t op = 0,
   int32_t state = 0,
   int32_t idata1 = 0,
   int32_t idata2 = 0,
   float fdata1 = 0,
   float fdata2 = 0,
   int32_t statetag = 0) {
  DSkillFrameStateOpBuilder builder_(_fbb);
  builder_.add_statetag(statetag);
  builder_.add_fdata2(fdata2);
  builder_.add_fdata1(fdata1);
  builder_.add_idata2(idata2);
  builder_.add_idata1(idata1);
  builder_.add_state(state);
  builder_.add_op(op);
  builder_.add_length(length);
  builder_.add_startframe(startframe);
  builder_.add_name(name);
  return builder_.Finish();
}

struct DSkillFaceAttacker FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  int32_t startframe() const { return GetField<int32_t>(6, 0); }
  int32_t length() const { return GetField<int32_t>(8, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, 6 /* startframe */) &&
           VerifyField<int32_t>(verifier, 8 /* length */) &&
           verifier.EndTable();
  }
};

struct DSkillFaceAttackerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_startframe(int32_t startframe) { fbb_.AddElement<int32_t>(6, startframe, 0); }
  void add_length(int32_t length) { fbb_.AddElement<int32_t>(8, length, 0); }
  DSkillFaceAttackerBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DSkillFaceAttackerBuilder &operator=(const DSkillFaceAttackerBuilder &);
  flatbuffers::Offset<DSkillFaceAttacker> Finish() {
    auto o = flatbuffers::Offset<DSkillFaceAttacker>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<DSkillFaceAttacker> CreateDSkillFaceAttacker(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   int32_t startframe = 0,
   int32_t length = 0) {
  DSkillFaceAttackerBuilder builder_(_fbb);
  builder_.add_length(length);
  builder_.add_startframe(startframe);
  builder_.add_name(name);
  return builder_.Finish();
}

struct DSkillFrameEventSceneShock FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  int32_t startframe() const { return GetField<int32_t>(6, 0); }
  int32_t length() const { return GetField<int32_t>(8, 0); }
  float time() const { return GetField<float>(10, 0); }
  float speed() const { return GetField<float>(12, 0); }
  float xrange() const { return GetField<float>(14, 0); }
  float yrange() const { return GetField<float>(16, 0); }
  uint8_t isNew() const { return GetField<uint8_t>(18, 0); }
  int32_t mode() const { return GetField<int32_t>(20, 0); }
  uint8_t decelerate() const { return GetField<uint8_t>(22, 0); }
  float xreduce() const { return GetField<float>(24, 0); }
  float yreduce() const { return GetField<float>(26, 0); }
  float radius() const { return GetField<float>(28, 0); }
  int32_t num() const { return GetField<int32_t>(30, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, 6 /* startframe */) &&
           VerifyField<int32_t>(verifier, 8 /* length */) &&
           VerifyField<float>(verifier, 10 /* time */) &&
           VerifyField<float>(verifier, 12 /* speed */) &&
           VerifyField<float>(verifier, 14 /* xrange */) &&
           VerifyField<float>(verifier, 16 /* yrange */) &&
           VerifyField<uint8_t>(verifier, 18 /* isNew */) &&
           VerifyField<int32_t>(verifier, 20 /* mode */) &&
           VerifyField<uint8_t>(verifier, 22 /* decelerate */) &&
           VerifyField<float>(verifier, 24 /* xreduce */) &&
           VerifyField<float>(verifier, 26 /* yreduce */) &&
           VerifyField<float>(verifier, 28 /* radius */) &&
           VerifyField<int32_t>(verifier, 30 /* num */) &&
           verifier.EndTable();
  }
};

struct DSkillFrameEventSceneShockBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_startframe(int32_t startframe) { fbb_.AddElement<int32_t>(6, startframe, 0); }
  void add_length(int32_t length) { fbb_.AddElement<int32_t>(8, length, 0); }
  void add_time(float time) { fbb_.AddElement<float>(10, time, 0); }
  void add_speed(float speed) { fbb_.AddElement<float>(12, speed, 0); }
  void add_xrange(float xrange) { fbb_.AddElement<float>(14, xrange, 0); }
  void add_yrange(float yrange) { fbb_.AddElement<float>(16, yrange, 0); }
  void add_isNew(uint8_t isNew) { fbb_.AddElement<uint8_t>(18, isNew, 0); }
  void add_mode(int32_t mode) { fbb_.AddElement<int32_t>(20, mode, 0); }
  void add_decelerate(uint8_t decelerate) { fbb_.AddElement<uint8_t>(22, decelerate, 0); }
  void add_xreduce(float xreduce) { fbb_.AddElement<float>(24, xreduce, 0); }
  void add_yreduce(float yreduce) { fbb_.AddElement<float>(26, yreduce, 0); }
  void add_radius(float radius) { fbb_.AddElement<float>(28, radius, 0); }
  void add_num(int32_t num) { fbb_.AddElement<int32_t>(30, num, 0); }
  DSkillFrameEventSceneShockBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DSkillFrameEventSceneShockBuilder &operator=(const DSkillFrameEventSceneShockBuilder &);
  flatbuffers::Offset<DSkillFrameEventSceneShock> Finish() {
    auto o = flatbuffers::Offset<DSkillFrameEventSceneShock>(fbb_.EndTable(start_, 14));
    return o;
  }
};

inline flatbuffers::Offset<DSkillFrameEventSceneShock> CreateDSkillFrameEventSceneShock(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   int32_t startframe = 0,
   int32_t length = 0,
   float time = 0,
   float speed = 0,
   float xrange = 0,
   float yrange = 0,
   uint8_t isNew = 0,
   int32_t mode = 0,
   uint8_t decelerate = 0,
   float xreduce = 0,
   float yreduce = 0,
   float radius = 0,
   int32_t num = 0) {
  DSkillFrameEventSceneShockBuilder builder_(_fbb);
  builder_.add_num(num);
  builder_.add_radius(radius);
  builder_.add_yreduce(yreduce);
  builder_.add_xreduce(xreduce);
  builder_.add_mode(mode);
  builder_.add_yrange(yrange);
  builder_.add_xrange(xrange);
  builder_.add_speed(speed);
  builder_.add_time(time);
  builder_.add_length(length);
  builder_.add_startframe(startframe);
  builder_.add_name(name);
  builder_.add_decelerate(decelerate);
  builder_.add_isNew(isNew);
  return builder_.Finish();
}

struct DActionData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  int32_t startframe() const { return GetField<int32_t>(6, 0); }
  int32_t length() const { return GetField<int32_t>(8, 0); }
  int32_t actionType() const { return GetField<int32_t>(10, 0); }
  float duration() const { return GetField<float>(12, 0); }
  float deltaScale() const { return GetField<float>(14, 0); }
  const Vector3 *deltaPos() const { return GetStruct<const Vector3 *>(16); }
  uint8_t ignoreBlock() const { return GetField<uint8_t>(18, 1); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, 6 /* startframe */) &&
           VerifyField<int32_t>(verifier, 8 /* length */) &&
           VerifyField<int32_t>(verifier, 10 /* actionType */) &&
           VerifyField<float>(verifier, 12 /* duration */) &&
           VerifyField<float>(verifier, 14 /* deltaScale */) &&
           VerifyField<Vector3>(verifier, 16 /* deltaPos */) &&
           VerifyField<uint8_t>(verifier, 18 /* ignoreBlock */) &&
           verifier.EndTable();
  }
};

struct DActionDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_startframe(int32_t startframe) { fbb_.AddElement<int32_t>(6, startframe, 0); }
  void add_length(int32_t length) { fbb_.AddElement<int32_t>(8, length, 0); }
  void add_actionType(int32_t actionType) { fbb_.AddElement<int32_t>(10, actionType, 0); }
  void add_duration(float duration) { fbb_.AddElement<float>(12, duration, 0); }
  void add_deltaScale(float deltaScale) { fbb_.AddElement<float>(14, deltaScale, 0); }
  void add_deltaPos(const Vector3 *deltaPos) { fbb_.AddStruct(16, deltaPos); }
  void add_ignoreBlock(uint8_t ignoreBlock) { fbb_.AddElement<uint8_t>(18, ignoreBlock, 1); }
  DActionDataBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DActionDataBuilder &operator=(const DActionDataBuilder &);
  flatbuffers::Offset<DActionData> Finish() {
    auto o = flatbuffers::Offset<DActionData>(fbb_.EndTable(start_, 8));
    return o;
  }
};

inline flatbuffers::Offset<DActionData> CreateDActionData(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   int32_t startframe = 0,
   int32_t length = 0,
   int32_t actionType = 0,
   float duration = 0,
   float deltaScale = 0,
   const Vector3 *deltaPos = 0,
   uint8_t ignoreBlock = 1) {
  DActionDataBuilder builder_(_fbb);
  builder_.add_deltaPos(deltaPos);
  builder_.add_deltaScale(deltaScale);
  builder_.add_duration(duration);
  builder_.add_actionType(actionType);
  builder_.add_length(length);
  builder_.add_startframe(startframe);
  builder_.add_name(name);
  builder_.add_ignoreBlock(ignoreBlock);
  return builder_.Finish();
}

struct DSkillBuff FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  int32_t startframe() const { return GetField<int32_t>(6, 0); }
  int32_t length() const { return GetField<int32_t>(8, 0); }
  float buffTime() const { return GetField<float>(10, 0); }
  int32_t buffID() const { return GetField<int32_t>(12, 0); }
  uint8_t phaseDelete() const { return GetField<uint8_t>(14, 0); }
  const flatbuffers::Vector<int32_t> *buffInfoList() const { return GetPointer<const flatbuffers::Vector<int32_t> *>(16); }
  uint8_t finishDeleteAll() const { return GetField<uint8_t>(18, 0); }
  int32_t level() const { return GetField<int32_t>(20, 0); }
  uint8_t levelBySkill() const { return GetField<uint8_t>(22, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, 6 /* startframe */) &&
           VerifyField<int32_t>(verifier, 8 /* length */) &&
           VerifyField<float>(verifier, 10 /* buffTime */) &&
           VerifyField<int32_t>(verifier, 12 /* buffID */) &&
           VerifyField<uint8_t>(verifier, 14 /* phaseDelete */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 16 /* buffInfoList */) &&
           verifier.Verify(buffInfoList()) &&
           VerifyField<uint8_t>(verifier, 18 /* finishDeleteAll */) &&
           VerifyField<int32_t>(verifier, 20 /* level */) &&
           VerifyField<uint8_t>(verifier, 22 /* levelBySkill */) &&
           verifier.EndTable();
  }
};

struct DSkillBuffBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_startframe(int32_t startframe) { fbb_.AddElement<int32_t>(6, startframe, 0); }
  void add_length(int32_t length) { fbb_.AddElement<int32_t>(8, length, 0); }
  void add_buffTime(float buffTime) { fbb_.AddElement<float>(10, buffTime, 0); }
  void add_buffID(int32_t buffID) { fbb_.AddElement<int32_t>(12, buffID, 0); }
  void add_phaseDelete(uint8_t phaseDelete) { fbb_.AddElement<uint8_t>(14, phaseDelete, 0); }
  void add_buffInfoList(flatbuffers::Offset<flatbuffers::Vector<int32_t>> buffInfoList) { fbb_.AddOffset(16, buffInfoList); }
  void add_finishDeleteAll(uint8_t finishDeleteAll) { fbb_.AddElement<uint8_t>(18, finishDeleteAll, 0); }
  void add_level(int32_t level) { fbb_.AddElement<int32_t>(20, level, 0); }
  void add_levelBySkill(uint8_t levelBySkill) { fbb_.AddElement<uint8_t>(22, levelBySkill, 0); }
  DSkillBuffBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DSkillBuffBuilder &operator=(const DSkillBuffBuilder &);
  flatbuffers::Offset<DSkillBuff> Finish() {
    auto o = flatbuffers::Offset<DSkillBuff>(fbb_.EndTable(start_, 10));
    return o;
  }
};

inline flatbuffers::Offset<DSkillBuff> CreateDSkillBuff(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   int32_t startframe = 0,
   int32_t length = 0,
   float buffTime = 0,
   int32_t buffID = 0,
   uint8_t phaseDelete = 0,
   flatbuffers::Offset<flatbuffers::Vector<int32_t>> buffInfoList = 0,
   uint8_t finishDeleteAll = 0,
   int32_t level = 0,
   uint8_t levelBySkill = 0) {
  DSkillBuffBuilder builder_(_fbb);
  builder_.add_level(level);
  builder_.add_buffInfoList(buffInfoList);
  builder_.add_buffID(buffID);
  builder_.add_buffTime(buffTime);
  builder_.add_length(length);
  builder_.add_startframe(startframe);
  builder_.add_name(name);
  builder_.add_levelBySkill(levelBySkill);
  builder_.add_finishDeleteAll(finishDeleteAll);
  builder_.add_phaseDelete(phaseDelete);
  return builder_.Finish();
}

struct DSkillSummon FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  int32_t startframe() const { return GetField<int32_t>(6, 0); }
  int32_t length() const { return GetField<int32_t>(8, 0); }
  int32_t summonID() const { return GetField<int32_t>(10, 0); }
  int32_t summonLevel() const { return GetField<int32_t>(12, 0); }
  uint8_t levelGrowBySkill() const { return GetField<uint8_t>(14, 0); }
  int32_t summonNum() const { return GetField<int32_t>(16, 0); }
  int32_t posType() const { return GetField<int32_t>(18, 0); }
  const flatbuffers::Vector<int32_t> *posType2() const { return GetPointer<const flatbuffers::Vector<int32_t> *>(20); }
  uint8_t isSameFace() const { return GetField<uint8_t>(22, 1); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, 6 /* startframe */) &&
           VerifyField<int32_t>(verifier, 8 /* length */) &&
           VerifyField<int32_t>(verifier, 10 /* summonID */) &&
           VerifyField<int32_t>(verifier, 12 /* summonLevel */) &&
           VerifyField<uint8_t>(verifier, 14 /* levelGrowBySkill */) &&
           VerifyField<int32_t>(verifier, 16 /* summonNum */) &&
           VerifyField<int32_t>(verifier, 18 /* posType */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 20 /* posType2 */) &&
           verifier.Verify(posType2()) &&
           VerifyField<uint8_t>(verifier, 22 /* isSameFace */) &&
           verifier.EndTable();
  }
};

struct DSkillSummonBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_startframe(int32_t startframe) { fbb_.AddElement<int32_t>(6, startframe, 0); }
  void add_length(int32_t length) { fbb_.AddElement<int32_t>(8, length, 0); }
  void add_summonID(int32_t summonID) { fbb_.AddElement<int32_t>(10, summonID, 0); }
  void add_summonLevel(int32_t summonLevel) { fbb_.AddElement<int32_t>(12, summonLevel, 0); }
  void add_levelGrowBySkill(uint8_t levelGrowBySkill) { fbb_.AddElement<uint8_t>(14, levelGrowBySkill, 0); }
  void add_summonNum(int32_t summonNum) { fbb_.AddElement<int32_t>(16, summonNum, 0); }
  void add_posType(int32_t posType) { fbb_.AddElement<int32_t>(18, posType, 0); }
  void add_posType2(flatbuffers::Offset<flatbuffers::Vector<int32_t>> posType2) { fbb_.AddOffset(20, posType2); }
  void add_isSameFace(uint8_t isSameFace) { fbb_.AddElement<uint8_t>(22, isSameFace, 1); }
  DSkillSummonBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DSkillSummonBuilder &operator=(const DSkillSummonBuilder &);
  flatbuffers::Offset<DSkillSummon> Finish() {
    auto o = flatbuffers::Offset<DSkillSummon>(fbb_.EndTable(start_, 10));
    return o;
  }
};

inline flatbuffers::Offset<DSkillSummon> CreateDSkillSummon(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   int32_t startframe = 0,
   int32_t length = 0,
   int32_t summonID = 0,
   int32_t summonLevel = 0,
   uint8_t levelGrowBySkill = 0,
   int32_t summonNum = 0,
   int32_t posType = 0,
   flatbuffers::Offset<flatbuffers::Vector<int32_t>> posType2 = 0,
   uint8_t isSameFace = 1) {
  DSkillSummonBuilder builder_(_fbb);
  builder_.add_posType2(posType2);
  builder_.add_posType(posType);
  builder_.add_summonNum(summonNum);
  builder_.add_summonLevel(summonLevel);
  builder_.add_summonID(summonID);
  builder_.add_length(length);
  builder_.add_startframe(startframe);
  builder_.add_name(name);
  builder_.add_isSameFace(isSameFace);
  builder_.add_levelGrowBySkill(levelGrowBySkill);
  return builder_.Finish();
}

struct DSkillMechanism FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  int32_t startframe() const { return GetField<int32_t>(6, 0); }
  int32_t length() const { return GetField<int32_t>(8, 0); }
  int32_t id() const { return GetField<int32_t>(10, 0); }
  float time() const { return GetField<float>(12, 0); }
  int32_t level() const { return GetField<int32_t>(14, 0); }
  uint8_t levelBySkill() const { return GetField<uint8_t>(16, 0); }
  uint8_t phaseDelete() const { return GetField<uint8_t>(18, 0); }
  uint8_t finishDeleteAll() const { return GetField<uint8_t>(20, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, 6 /* startframe */) &&
           VerifyField<int32_t>(verifier, 8 /* length */) &&
           VerifyField<int32_t>(verifier, 10 /* id */) &&
           VerifyField<float>(verifier, 12 /* time */) &&
           VerifyField<int32_t>(verifier, 14 /* level */) &&
           VerifyField<uint8_t>(verifier, 16 /* levelBySkill */) &&
           VerifyField<uint8_t>(verifier, 18 /* phaseDelete */) &&
           VerifyField<uint8_t>(verifier, 20 /* finishDeleteAll */) &&
           verifier.EndTable();
  }
};

struct DSkillMechanismBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_startframe(int32_t startframe) { fbb_.AddElement<int32_t>(6, startframe, 0); }
  void add_length(int32_t length) { fbb_.AddElement<int32_t>(8, length, 0); }
  void add_id(int32_t id) { fbb_.AddElement<int32_t>(10, id, 0); }
  void add_time(float time) { fbb_.AddElement<float>(12, time, 0); }
  void add_level(int32_t level) { fbb_.AddElement<int32_t>(14, level, 0); }
  void add_levelBySkill(uint8_t levelBySkill) { fbb_.AddElement<uint8_t>(16, levelBySkill, 0); }
  void add_phaseDelete(uint8_t phaseDelete) { fbb_.AddElement<uint8_t>(18, phaseDelete, 0); }
  void add_finishDeleteAll(uint8_t finishDeleteAll) { fbb_.AddElement<uint8_t>(20, finishDeleteAll, 0); }
  DSkillMechanismBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DSkillMechanismBuilder &operator=(const DSkillMechanismBuilder &);
  flatbuffers::Offset<DSkillMechanism> Finish() {
    auto o = flatbuffers::Offset<DSkillMechanism>(fbb_.EndTable(start_, 9));
    return o;
  }
};

inline flatbuffers::Offset<DSkillMechanism> CreateDSkillMechanism(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   int32_t startframe = 0,
   int32_t length = 0,
   int32_t id = 0,
   float time = 0,
   int32_t level = 0,
   uint8_t levelBySkill = 0,
   uint8_t phaseDelete = 0,
   uint8_t finishDeleteAll = 0) {
  DSkillMechanismBuilder builder_(_fbb);
  builder_.add_level(level);
  builder_.add_time(time);
  builder_.add_id(id);
  builder_.add_length(length);
  builder_.add_startframe(startframe);
  builder_.add_name(name);
  builder_.add_finishDeleteAll(finishDeleteAll);
  builder_.add_phaseDelete(phaseDelete);
  builder_.add_levelBySkill(levelBySkill);
  return builder_.Finish();
}

struct FBSkillData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *_name() const { return GetPointer<const flatbuffers::String *>(4); }
  int32_t skillID() const { return GetField<int32_t>(6, 0); }
  int32_t skillPriority() const { return GetField<int32_t>(8, 0); }
  const flatbuffers::Vector<int32_t> *skillPhases() const { return GetPointer<const flatbuffers::Vector<int32_t> *>(10); }
  uint8_t relatedAttackSpeed() const { return GetField<uint8_t>(12, 0); }
  int32_t attackSpeed() const { return GetField<int32_t>(14, 0); }
  int32_t isLoop() const { return GetField<int32_t>(16, 0); }
  uint8_t notLoopLastFrame() const { return GetField<uint8_t>(18, 0); }
  uint8_t loopAnimation() const { return GetField<uint8_t>(20, 0); }
  const flatbuffers::String *hitEffect() const { return GetPointer<const flatbuffers::String *>(22); }
  const flatbuffers::String *goHitEffectAsset() const { return GetPointer<const flatbuffers::String *>(24); }
  const flatbuffers::String *goSFXAsset() const { return GetPointer<const flatbuffers::String *>(26); }
  int32_t hitSFXID() const { return GetField<int32_t>(28, 0); }
  int32_t hurtType() const { return GetField<int32_t>(30, 0); }
  float hurtTime() const { return GetField<float>(32, 0); }
  int32_t hurtPause() const { return GetField<int32_t>(34, 0); }
  float hurtPauseTime() const { return GetField<float>(36, 0); }
  float forcex() const { return GetField<float>(38, 0); }
  float forcey() const { return GetField<float>(40, 0); }
  const flatbuffers::String *dscription() const { return GetPointer<const flatbuffers::String *>(42); }
  const flatbuffers::String *caracterAsset() const { return GetPointer<const flatbuffers::String *>(44); }
  int32_t fps() const { return GetField<int32_t>(46, 60); }
  const flatbuffers::String *animationName() const { return GetPointer<const flatbuffers::String *>(48); }
  const flatbuffers::String *moveName() const { return GetPointer<const flatbuffers::String *>(50); }
  int32_t wapMode() const { return GetField<int32_t>(52, 0); }
  float iterpolationSpeed() const { return GetField<float>(54, 0); }
  float animationSpeed() const { return GetField<float>(56, 1); }
  int32_t totalFrames() const { return GetField<int32_t>(58, 15); }
  int32_t startUpFrames() const { return GetField<int32_t>(60, 5); }
  int32_t activeFrames() const { return GetField<int32_t>(62, 5); }
  int32_t rcoveryFrames() const { return GetField<int32_t>(64, 5); }
  uint8_t ueSpellBar() const { return GetField<uint8_t>(66, 0); }
  float sellBarTime() const { return GetField<float>(68, 0); }
  int32_t cmboStartFrame() const { return GetField<int32_t>(70, 0); }
  int32_t cmboSkillID() const { return GetField<int32_t>(72, 0); }
  float skilltime() const { return GetField<float>(74, 0); }
  uint8_t cameraRestore() const { return GetField<uint8_t>(76, 0); }
  float cameraRestoreTime() const { return GetField<float>(78, 0); }
  float grabPosx() const { return GetField<float>(80, 0); }
  float grabPosy() const { return GetField<float>(82, 0); }
  float grabEndForceX() const { return GetField<float>(84, 0); }
  float grabEndForceY() const { return GetField<float>(86, 0); }
  uint8_t hitSpreadOut() const { return GetField<uint8_t>(88, 0); }
  float grabTime() const { return GetField<float>(90, 0); }
  int32_t grabEndEffectType() const { return GetField<int32_t>(92, 0); }
  int32_t grabAction() const { return GetField<int32_t>(94, 0); }
  int32_t grabNum() const { return GetField<int32_t>(96, 0); }
  float grabMoveSpeed() const { return GetField<float>(98, 0); }
  uint8_t grabSupportQuickPressDismis() const { return GetField<uint8_t>(100, 0); }
  uint8_t notGrabBati() const { return GetField<uint8_t>(102, 0); }
  uint8_t notGrabGeDang() const { return GetField<uint8_t>(104, 0); }
  uint8_t notUseGrabSetPos() const { return GetField<uint8_t>(106, 0); }
  uint8_t notGrabToBlock() const { return GetField<uint8_t>(108, 0); }
  int32_t buffInfoId() const { return GetField<int32_t>(110, 0); }
  int32_t buffInfoIdToSelf() const { return GetField<int32_t>(112, 0); }
  int32_t buffInfoIdToOther() const { return GetField<int32_t>(114, 0); }
  uint8_t isCharge() const { return GetField<uint8_t>(116, 0); }
  const ChargeConfig *chargeConfig() const { return GetPointer<const ChargeConfig *>(118); }
  uint8_t isSpeicalOperate() const { return GetField<uint8_t>(120, 0); }
  const OperationConfig *operationConfig() const { return GetPointer<const OperationConfig *>(122); }
  uint8_t isUseSelectSeatJoystick() const { return GetField<uint8_t>(124, 0); }
  int32_t actionSelectPhase() const { return GetField<int32_t>(126, 0); }
  const flatbuffers::Vector<int32_t> *actionSelect() const { return GetPointer<const flatbuffers::Vector<int32_t> *>(128); }
  const SkillJoystickConfig *skillJoystickConfig() const { return GetPointer<const SkillJoystickConfig *>(130); }
  const flatbuffers::Vector<flatbuffers::Offset<SkillEvent>> *skillEvents() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SkillEvent>> *>(132); }
  int32_t triggerType() const { return GetField<int32_t>(134, 0); }
  const flatbuffers::Vector<flatbuffers::Offset<HurtDecisionBox>> *HurtBlocks() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<HurtDecisionBox>> *>(136); }
  const flatbuffers::Vector<flatbuffers::Offset<DefenceDecisionBox>> *DefenceBlocks() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DefenceDecisionBox>> *>(138); }
  const flatbuffers::Vector<flatbuffers::Offset<EntityAttachFrames>> *attachFrames() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EntityAttachFrames>> *>(140); }
  const flatbuffers::Vector<flatbuffers::Offset<EffectsFrames>> *effectFrames() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EffectsFrames>> *>(142); }
  const flatbuffers::Vector<flatbuffers::Offset<EntityFrames>> *entityFrames() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EntityFrames>> *>(144); }
  const flatbuffers::Vector<flatbuffers::Offset<DSkillFrameTag>> *frameTags() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DSkillFrameTag>> *>(146); }
  const flatbuffers::Vector<flatbuffers::Offset<DSkillFrameGrap>> *frameGrap() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DSkillFrameGrap>> *>(148); }
  const flatbuffers::Vector<flatbuffers::Offset<DSkillFrameStateOp>> *stateop() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DSkillFrameStateOp>> *>(150); }
  const flatbuffers::Vector<flatbuffers::Offset<DSkillPropertyModify>> *properModify() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DSkillPropertyModify>> *>(152); }
  const flatbuffers::Vector<flatbuffers::Offset<DSkillFrameEventSceneShock>> *shocks() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DSkillFrameEventSceneShock>> *>(154); }
  const flatbuffers::Vector<flatbuffers::Offset<DSkillSfx>> *sfx() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DSkillSfx>> *>(156); }
  const flatbuffers::Vector<flatbuffers::Offset<DSkillFrameEffect>> *frameEffects() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DSkillFrameEffect>> *>(158); }
  const flatbuffers::Vector<flatbuffers::Offset<DSkillCameraMove>> *cameraMoves() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DSkillCameraMove>> *>(160); }
  const flatbuffers::Vector<flatbuffers::Offset<DSkillWalkControl>> *walkControl() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DSkillWalkControl>> *>(162); }
  const flatbuffers::Vector<flatbuffers::Offset<DActionData>> *actions() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DActionData>> *>(164); }
  const flatbuffers::Vector<flatbuffers::Offset<DSkillBuff>> *buffs() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DSkillBuff>> *>(166); }
  const flatbuffers::Vector<flatbuffers::Offset<DSkillSummon>> *summons() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DSkillSummon>> *>(168); }
  const flatbuffers::Vector<flatbuffers::Offset<DSkillMechanism>> *mechanisms() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DSkillMechanism>> *>(170); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* _name */) &&
           verifier.Verify(_name()) &&
           VerifyField<int32_t>(verifier, 6 /* skillID */) &&
           VerifyField<int32_t>(verifier, 8 /* skillPriority */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* skillPhases */) &&
           verifier.Verify(skillPhases()) &&
           VerifyField<uint8_t>(verifier, 12 /* relatedAttackSpeed */) &&
           VerifyField<int32_t>(verifier, 14 /* attackSpeed */) &&
           VerifyField<int32_t>(verifier, 16 /* isLoop */) &&
           VerifyField<uint8_t>(verifier, 18 /* notLoopLastFrame */) &&
           VerifyField<uint8_t>(verifier, 20 /* loopAnimation */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 22 /* hitEffect */) &&
           verifier.Verify(hitEffect()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 24 /* goHitEffectAsset */) &&
           verifier.Verify(goHitEffectAsset()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 26 /* goSFXAsset */) &&
           verifier.Verify(goSFXAsset()) &&
           VerifyField<int32_t>(verifier, 28 /* hitSFXID */) &&
           VerifyField<int32_t>(verifier, 30 /* hurtType */) &&
           VerifyField<float>(verifier, 32 /* hurtTime */) &&
           VerifyField<int32_t>(verifier, 34 /* hurtPause */) &&
           VerifyField<float>(verifier, 36 /* hurtPauseTime */) &&
           VerifyField<float>(verifier, 38 /* forcex */) &&
           VerifyField<float>(verifier, 40 /* forcey */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 42 /* dscription */) &&
           verifier.Verify(dscription()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 44 /* caracterAsset */) &&
           verifier.Verify(caracterAsset()) &&
           VerifyField<int32_t>(verifier, 46 /* fps */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 48 /* animationName */) &&
           verifier.Verify(animationName()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 50 /* moveName */) &&
           verifier.Verify(moveName()) &&
           VerifyField<int32_t>(verifier, 52 /* wapMode */) &&
           VerifyField<float>(verifier, 54 /* iterpolationSpeed */) &&
           VerifyField<float>(verifier, 56 /* animationSpeed */) &&
           VerifyField<int32_t>(verifier, 58 /* totalFrames */) &&
           VerifyField<int32_t>(verifier, 60 /* startUpFrames */) &&
           VerifyField<int32_t>(verifier, 62 /* activeFrames */) &&
           VerifyField<int32_t>(verifier, 64 /* rcoveryFrames */) &&
           VerifyField<uint8_t>(verifier, 66 /* ueSpellBar */) &&
           VerifyField<float>(verifier, 68 /* sellBarTime */) &&
           VerifyField<int32_t>(verifier, 70 /* cmboStartFrame */) &&
           VerifyField<int32_t>(verifier, 72 /* cmboSkillID */) &&
           VerifyField<float>(verifier, 74 /* skilltime */) &&
           VerifyField<uint8_t>(verifier, 76 /* cameraRestore */) &&
           VerifyField<float>(verifier, 78 /* cameraRestoreTime */) &&
           VerifyField<float>(verifier, 80 /* grabPosx */) &&
           VerifyField<float>(verifier, 82 /* grabPosy */) &&
           VerifyField<float>(verifier, 84 /* grabEndForceX */) &&
           VerifyField<float>(verifier, 86 /* grabEndForceY */) &&
           VerifyField<uint8_t>(verifier, 88 /* hitSpreadOut */) &&
           VerifyField<float>(verifier, 90 /* grabTime */) &&
           VerifyField<int32_t>(verifier, 92 /* grabEndEffectType */) &&
           VerifyField<int32_t>(verifier, 94 /* grabAction */) &&
           VerifyField<int32_t>(verifier, 96 /* grabNum */) &&
           VerifyField<float>(verifier, 98 /* grabMoveSpeed */) &&
           VerifyField<uint8_t>(verifier, 100 /* grabSupportQuickPressDismis */) &&
           VerifyField<uint8_t>(verifier, 102 /* notGrabBati */) &&
           VerifyField<uint8_t>(verifier, 104 /* notGrabGeDang */) &&
           VerifyField<uint8_t>(verifier, 106 /* notUseGrabSetPos */) &&
           VerifyField<uint8_t>(verifier, 108 /* notGrabToBlock */) &&
           VerifyField<int32_t>(verifier, 110 /* buffInfoId */) &&
           VerifyField<int32_t>(verifier, 112 /* buffInfoIdToSelf */) &&
           VerifyField<int32_t>(verifier, 114 /* buffInfoIdToOther */) &&
           VerifyField<uint8_t>(verifier, 116 /* isCharge */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 118 /* chargeConfig */) &&
           verifier.VerifyTable(chargeConfig()) &&
           VerifyField<uint8_t>(verifier, 120 /* isSpeicalOperate */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 122 /* operationConfig */) &&
           verifier.VerifyTable(operationConfig()) &&
           VerifyField<uint8_t>(verifier, 124 /* isUseSelectSeatJoystick */) &&
           VerifyField<int32_t>(verifier, 126 /* actionSelectPhase */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 128 /* actionSelect */) &&
           verifier.Verify(actionSelect()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 130 /* skillJoystickConfig */) &&
           verifier.VerifyTable(skillJoystickConfig()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 132 /* skillEvents */) &&
           verifier.Verify(skillEvents()) &&
           verifier.VerifyVectorOfTables(skillEvents()) &&
           VerifyField<int32_t>(verifier, 134 /* triggerType */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 136 /* HurtBlocks */) &&
           verifier.Verify(HurtBlocks()) &&
           verifier.VerifyVectorOfTables(HurtBlocks()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 138 /* DefenceBlocks */) &&
           verifier.Verify(DefenceBlocks()) &&
           verifier.VerifyVectorOfTables(DefenceBlocks()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 140 /* attachFrames */) &&
           verifier.Verify(attachFrames()) &&
           verifier.VerifyVectorOfTables(attachFrames()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 142 /* effectFrames */) &&
           verifier.Verify(effectFrames()) &&
           verifier.VerifyVectorOfTables(effectFrames()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 144 /* entityFrames */) &&
           verifier.Verify(entityFrames()) &&
           verifier.VerifyVectorOfTables(entityFrames()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 146 /* frameTags */) &&
           verifier.Verify(frameTags()) &&
           verifier.VerifyVectorOfTables(frameTags()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 148 /* frameGrap */) &&
           verifier.Verify(frameGrap()) &&
           verifier.VerifyVectorOfTables(frameGrap()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 150 /* stateop */) &&
           verifier.Verify(stateop()) &&
           verifier.VerifyVectorOfTables(stateop()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 152 /* properModify */) &&
           verifier.Verify(properModify()) &&
           verifier.VerifyVectorOfTables(properModify()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 154 /* shocks */) &&
           verifier.Verify(shocks()) &&
           verifier.VerifyVectorOfTables(shocks()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 156 /* sfx */) &&
           verifier.Verify(sfx()) &&
           verifier.VerifyVectorOfTables(sfx()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 158 /* frameEffects */) &&
           verifier.Verify(frameEffects()) &&
           verifier.VerifyVectorOfTables(frameEffects()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 160 /* cameraMoves */) &&
           verifier.Verify(cameraMoves()) &&
           verifier.VerifyVectorOfTables(cameraMoves()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 162 /* walkControl */) &&
           verifier.Verify(walkControl()) &&
           verifier.VerifyVectorOfTables(walkControl()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 164 /* actions */) &&
           verifier.Verify(actions()) &&
           verifier.VerifyVectorOfTables(actions()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 166 /* buffs */) &&
           verifier.Verify(buffs()) &&
           verifier.VerifyVectorOfTables(buffs()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 168 /* summons */) &&
           verifier.Verify(summons()) &&
           verifier.VerifyVectorOfTables(summons()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 170 /* mechanisms */) &&
           verifier.Verify(mechanisms()) &&
           verifier.VerifyVectorOfTables(mechanisms()) &&
           verifier.EndTable();
  }
};

struct FBSkillDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add__name(flatbuffers::Offset<flatbuffers::String> _name) { fbb_.AddOffset(4, _name); }
  void add_skillID(int32_t skillID) { fbb_.AddElement<int32_t>(6, skillID, 0); }
  void add_skillPriority(int32_t skillPriority) { fbb_.AddElement<int32_t>(8, skillPriority, 0); }
  void add_skillPhases(flatbuffers::Offset<flatbuffers::Vector<int32_t>> skillPhases) { fbb_.AddOffset(10, skillPhases); }
  void add_relatedAttackSpeed(uint8_t relatedAttackSpeed) { fbb_.AddElement<uint8_t>(12, relatedAttackSpeed, 0); }
  void add_attackSpeed(int32_t attackSpeed) { fbb_.AddElement<int32_t>(14, attackSpeed, 0); }
  void add_isLoop(int32_t isLoop) { fbb_.AddElement<int32_t>(16, isLoop, 0); }
  void add_notLoopLastFrame(uint8_t notLoopLastFrame) { fbb_.AddElement<uint8_t>(18, notLoopLastFrame, 0); }
  void add_loopAnimation(uint8_t loopAnimation) { fbb_.AddElement<uint8_t>(20, loopAnimation, 0); }
  void add_hitEffect(flatbuffers::Offset<flatbuffers::String> hitEffect) { fbb_.AddOffset(22, hitEffect); }
  void add_goHitEffectAsset(flatbuffers::Offset<flatbuffers::String> goHitEffectAsset) { fbb_.AddOffset(24, goHitEffectAsset); }
  void add_goSFXAsset(flatbuffers::Offset<flatbuffers::String> goSFXAsset) { fbb_.AddOffset(26, goSFXAsset); }
  void add_hitSFXID(int32_t hitSFXID) { fbb_.AddElement<int32_t>(28, hitSFXID, 0); }
  void add_hurtType(int32_t hurtType) { fbb_.AddElement<int32_t>(30, hurtType, 0); }
  void add_hurtTime(float hurtTime) { fbb_.AddElement<float>(32, hurtTime, 0); }
  void add_hurtPause(int32_t hurtPause) { fbb_.AddElement<int32_t>(34, hurtPause, 0); }
  void add_hurtPauseTime(float hurtPauseTime) { fbb_.AddElement<float>(36, hurtPauseTime, 0); }
  void add_forcex(float forcex) { fbb_.AddElement<float>(38, forcex, 0); }
  void add_forcey(float forcey) { fbb_.AddElement<float>(40, forcey, 0); }
  void add_dscription(flatbuffers::Offset<flatbuffers::String> dscription) { fbb_.AddOffset(42, dscription); }
  void add_caracterAsset(flatbuffers::Offset<flatbuffers::String> caracterAsset) { fbb_.AddOffset(44, caracterAsset); }
  void add_fps(int32_t fps) { fbb_.AddElement<int32_t>(46, fps, 60); }
  void add_animationName(flatbuffers::Offset<flatbuffers::String> animationName) { fbb_.AddOffset(48, animationName); }
  void add_moveName(flatbuffers::Offset<flatbuffers::String> moveName) { fbb_.AddOffset(50, moveName); }
  void add_wapMode(int32_t wapMode) { fbb_.AddElement<int32_t>(52, wapMode, 0); }
  void add_iterpolationSpeed(float iterpolationSpeed) { fbb_.AddElement<float>(54, iterpolationSpeed, 0); }
  void add_animationSpeed(float animationSpeed) { fbb_.AddElement<float>(56, animationSpeed, 1); }
  void add_totalFrames(int32_t totalFrames) { fbb_.AddElement<int32_t>(58, totalFrames, 15); }
  void add_startUpFrames(int32_t startUpFrames) { fbb_.AddElement<int32_t>(60, startUpFrames, 5); }
  void add_activeFrames(int32_t activeFrames) { fbb_.AddElement<int32_t>(62, activeFrames, 5); }
  void add_rcoveryFrames(int32_t rcoveryFrames) { fbb_.AddElement<int32_t>(64, rcoveryFrames, 5); }
  void add_ueSpellBar(uint8_t ueSpellBar) { fbb_.AddElement<uint8_t>(66, ueSpellBar, 0); }
  void add_sellBarTime(float sellBarTime) { fbb_.AddElement<float>(68, sellBarTime, 0); }
  void add_cmboStartFrame(int32_t cmboStartFrame) { fbb_.AddElement<int32_t>(70, cmboStartFrame, 0); }
  void add_cmboSkillID(int32_t cmboSkillID) { fbb_.AddElement<int32_t>(72, cmboSkillID, 0); }
  void add_skilltime(float skilltime) { fbb_.AddElement<float>(74, skilltime, 0); }
  void add_cameraRestore(uint8_t cameraRestore) { fbb_.AddElement<uint8_t>(76, cameraRestore, 0); }
  void add_cameraRestoreTime(float cameraRestoreTime) { fbb_.AddElement<float>(78, cameraRestoreTime, 0); }
  void add_grabPosx(float grabPosx) { fbb_.AddElement<float>(80, grabPosx, 0); }
  void add_grabPosy(float grabPosy) { fbb_.AddElement<float>(82, grabPosy, 0); }
  void add_grabEndForceX(float grabEndForceX) { fbb_.AddElement<float>(84, grabEndForceX, 0); }
  void add_grabEndForceY(float grabEndForceY) { fbb_.AddElement<float>(86, grabEndForceY, 0); }
  void add_hitSpreadOut(uint8_t hitSpreadOut) { fbb_.AddElement<uint8_t>(88, hitSpreadOut, 0); }
  void add_grabTime(float grabTime) { fbb_.AddElement<float>(90, grabTime, 0); }
  void add_grabEndEffectType(int32_t grabEndEffectType) { fbb_.AddElement<int32_t>(92, grabEndEffectType, 0); }
  void add_grabAction(int32_t grabAction) { fbb_.AddElement<int32_t>(94, grabAction, 0); }
  void add_grabNum(int32_t grabNum) { fbb_.AddElement<int32_t>(96, grabNum, 0); }
  void add_grabMoveSpeed(float grabMoveSpeed) { fbb_.AddElement<float>(98, grabMoveSpeed, 0); }
  void add_grabSupportQuickPressDismis(uint8_t grabSupportQuickPressDismis) { fbb_.AddElement<uint8_t>(100, grabSupportQuickPressDismis, 0); }
  void add_notGrabBati(uint8_t notGrabBati) { fbb_.AddElement<uint8_t>(102, notGrabBati, 0); }
  void add_notGrabGeDang(uint8_t notGrabGeDang) { fbb_.AddElement<uint8_t>(104, notGrabGeDang, 0); }
  void add_notUseGrabSetPos(uint8_t notUseGrabSetPos) { fbb_.AddElement<uint8_t>(106, notUseGrabSetPos, 0); }
  void add_notGrabToBlock(uint8_t notGrabToBlock) { fbb_.AddElement<uint8_t>(108, notGrabToBlock, 0); }
  void add_buffInfoId(int32_t buffInfoId) { fbb_.AddElement<int32_t>(110, buffInfoId, 0); }
  void add_buffInfoIdToSelf(int32_t buffInfoIdToSelf) { fbb_.AddElement<int32_t>(112, buffInfoIdToSelf, 0); }
  void add_buffInfoIdToOther(int32_t buffInfoIdToOther) { fbb_.AddElement<int32_t>(114, buffInfoIdToOther, 0); }
  void add_isCharge(uint8_t isCharge) { fbb_.AddElement<uint8_t>(116, isCharge, 0); }
  void add_chargeConfig(flatbuffers::Offset<ChargeConfig> chargeConfig) { fbb_.AddOffset(118, chargeConfig); }
  void add_isSpeicalOperate(uint8_t isSpeicalOperate) { fbb_.AddElement<uint8_t>(120, isSpeicalOperate, 0); }
  void add_operationConfig(flatbuffers::Offset<OperationConfig> operationConfig) { fbb_.AddOffset(122, operationConfig); }
  void add_isUseSelectSeatJoystick(uint8_t isUseSelectSeatJoystick) { fbb_.AddElement<uint8_t>(124, isUseSelectSeatJoystick, 0); }
  void add_actionSelectPhase(int32_t actionSelectPhase) { fbb_.AddElement<int32_t>(126, actionSelectPhase, 0); }
  void add_actionSelect(flatbuffers::Offset<flatbuffers::Vector<int32_t>> actionSelect) { fbb_.AddOffset(128, actionSelect); }
  void add_skillJoystickConfig(flatbuffers::Offset<SkillJoystickConfig> skillJoystickConfig) { fbb_.AddOffset(130, skillJoystickConfig); }
  void add_skillEvents(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SkillEvent>>> skillEvents) { fbb_.AddOffset(132, skillEvents); }
  void add_triggerType(int32_t triggerType) { fbb_.AddElement<int32_t>(134, triggerType, 0); }
  void add_HurtBlocks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HurtDecisionBox>>> HurtBlocks) { fbb_.AddOffset(136, HurtBlocks); }
  void add_DefenceBlocks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DefenceDecisionBox>>> DefenceBlocks) { fbb_.AddOffset(138, DefenceBlocks); }
  void add_attachFrames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EntityAttachFrames>>> attachFrames) { fbb_.AddOffset(140, attachFrames); }
  void add_effectFrames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EffectsFrames>>> effectFrames) { fbb_.AddOffset(142, effectFrames); }
  void add_entityFrames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EntityFrames>>> entityFrames) { fbb_.AddOffset(144, entityFrames); }
  void add_frameTags(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DSkillFrameTag>>> frameTags) { fbb_.AddOffset(146, frameTags); }
  void add_frameGrap(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DSkillFrameGrap>>> frameGrap) { fbb_.AddOffset(148, frameGrap); }
  void add_stateop(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DSkillFrameStateOp>>> stateop) { fbb_.AddOffset(150, stateop); }
  void add_properModify(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DSkillPropertyModify>>> properModify) { fbb_.AddOffset(152, properModify); }
  void add_shocks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DSkillFrameEventSceneShock>>> shocks) { fbb_.AddOffset(154, shocks); }
  void add_sfx(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DSkillSfx>>> sfx) { fbb_.AddOffset(156, sfx); }
  void add_frameEffects(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DSkillFrameEffect>>> frameEffects) { fbb_.AddOffset(158, frameEffects); }
  void add_cameraMoves(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DSkillCameraMove>>> cameraMoves) { fbb_.AddOffset(160, cameraMoves); }
  void add_walkControl(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DSkillWalkControl>>> walkControl) { fbb_.AddOffset(162, walkControl); }
  void add_actions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DActionData>>> actions) { fbb_.AddOffset(164, actions); }
  void add_buffs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DSkillBuff>>> buffs) { fbb_.AddOffset(166, buffs); }
  void add_summons(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DSkillSummon>>> summons) { fbb_.AddOffset(168, summons); }
  void add_mechanisms(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DSkillMechanism>>> mechanisms) { fbb_.AddOffset(170, mechanisms); }
  FBSkillDataBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  FBSkillDataBuilder &operator=(const FBSkillDataBuilder &);
  flatbuffers::Offset<FBSkillData> Finish() {
    auto o = flatbuffers::Offset<FBSkillData>(fbb_.EndTable(start_, 84));
    return o;
  }
};

inline flatbuffers::Offset<FBSkillData> CreateFBSkillData(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> _name = 0,
   int32_t skillID = 0,
   int32_t skillPriority = 0,
   flatbuffers::Offset<flatbuffers::Vector<int32_t>> skillPhases = 0,
   uint8_t relatedAttackSpeed = 0,
   int32_t attackSpeed = 0,
   int32_t isLoop = 0,
   uint8_t notLoopLastFrame = 0,
   uint8_t loopAnimation = 0,
   flatbuffers::Offset<flatbuffers::String> hitEffect = 0,
   flatbuffers::Offset<flatbuffers::String> goHitEffectAsset = 0,
   flatbuffers::Offset<flatbuffers::String> goSFXAsset = 0,
   int32_t hitSFXID = 0,
   int32_t hurtType = 0,
   float hurtTime = 0,
   int32_t hurtPause = 0,
   float hurtPauseTime = 0,
   float forcex = 0,
   float forcey = 0,
   flatbuffers::Offset<flatbuffers::String> dscription = 0,
   flatbuffers::Offset<flatbuffers::String> caracterAsset = 0,
   int32_t fps = 60,
   flatbuffers::Offset<flatbuffers::String> animationName = 0,
   flatbuffers::Offset<flatbuffers::String> moveName = 0,
   int32_t wapMode = 0,
   float iterpolationSpeed = 0,
   float animationSpeed = 1,
   int32_t totalFrames = 15,
   int32_t startUpFrames = 5,
   int32_t activeFrames = 5,
   int32_t rcoveryFrames = 5,
   uint8_t ueSpellBar = 0,
   float sellBarTime = 0,
   int32_t cmboStartFrame = 0,
   int32_t cmboSkillID = 0,
   float skilltime = 0,
   uint8_t cameraRestore = 0,
   float cameraRestoreTime = 0,
   float grabPosx = 0,
   float grabPosy = 0,
   float grabEndForceX = 0,
   float grabEndForceY = 0,
   uint8_t hitSpreadOut = 0,
   float grabTime = 0,
   int32_t grabEndEffectType = 0,
   int32_t grabAction = 0,
   int32_t grabNum = 0,
   float grabMoveSpeed = 0,
   uint8_t grabSupportQuickPressDismis = 0,
   uint8_t notGrabBati = 0,
   uint8_t notGrabGeDang = 0,
   uint8_t notUseGrabSetPos = 0,
   uint8_t notGrabToBlock = 0,
   int32_t buffInfoId = 0,
   int32_t buffInfoIdToSelf = 0,
   int32_t buffInfoIdToOther = 0,
   uint8_t isCharge = 0,
   flatbuffers::Offset<ChargeConfig> chargeConfig = 0,
   uint8_t isSpeicalOperate = 0,
   flatbuffers::Offset<OperationConfig> operationConfig = 0,
   uint8_t isUseSelectSeatJoystick = 0,
   int32_t actionSelectPhase = 0,
   flatbuffers::Offset<flatbuffers::Vector<int32_t>> actionSelect = 0,
   flatbuffers::Offset<SkillJoystickConfig> skillJoystickConfig = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SkillEvent>>> skillEvents = 0,
   int32_t triggerType = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HurtDecisionBox>>> HurtBlocks = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DefenceDecisionBox>>> DefenceBlocks = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EntityAttachFrames>>> attachFrames = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EffectsFrames>>> effectFrames = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EntityFrames>>> entityFrames = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DSkillFrameTag>>> frameTags = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DSkillFrameGrap>>> frameGrap = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DSkillFrameStateOp>>> stateop = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DSkillPropertyModify>>> properModify = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DSkillFrameEventSceneShock>>> shocks = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DSkillSfx>>> sfx = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DSkillFrameEffect>>> frameEffects = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DSkillCameraMove>>> cameraMoves = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DSkillWalkControl>>> walkControl = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DActionData>>> actions = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DSkillBuff>>> buffs = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DSkillSummon>>> summons = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DSkillMechanism>>> mechanisms = 0) {
  FBSkillDataBuilder builder_(_fbb);
  builder_.add_mechanisms(mechanisms);
  builder_.add_summons(summons);
  builder_.add_buffs(buffs);
  builder_.add_actions(actions);
  builder_.add_walkControl(walkControl);
  builder_.add_cameraMoves(cameraMoves);
  builder_.add_frameEffects(frameEffects);
  builder_.add_sfx(sfx);
  builder_.add_shocks(shocks);
  builder_.add_properModify(properModify);
  builder_.add_stateop(stateop);
  builder_.add_frameGrap(frameGrap);
  builder_.add_frameTags(frameTags);
  builder_.add_entityFrames(entityFrames);
  builder_.add_effectFrames(effectFrames);
  builder_.add_attachFrames(attachFrames);
  builder_.add_DefenceBlocks(DefenceBlocks);
  builder_.add_HurtBlocks(HurtBlocks);
  builder_.add_triggerType(triggerType);
  builder_.add_skillEvents(skillEvents);
  builder_.add_skillJoystickConfig(skillJoystickConfig);
  builder_.add_actionSelect(actionSelect);
  builder_.add_actionSelectPhase(actionSelectPhase);
  builder_.add_operationConfig(operationConfig);
  builder_.add_chargeConfig(chargeConfig);
  builder_.add_buffInfoIdToOther(buffInfoIdToOther);
  builder_.add_buffInfoIdToSelf(buffInfoIdToSelf);
  builder_.add_buffInfoId(buffInfoId);
  builder_.add_grabMoveSpeed(grabMoveSpeed);
  builder_.add_grabNum(grabNum);
  builder_.add_grabAction(grabAction);
  builder_.add_grabEndEffectType(grabEndEffectType);
  builder_.add_grabTime(grabTime);
  builder_.add_grabEndForceY(grabEndForceY);
  builder_.add_grabEndForceX(grabEndForceX);
  builder_.add_grabPosy(grabPosy);
  builder_.add_grabPosx(grabPosx);
  builder_.add_cameraRestoreTime(cameraRestoreTime);
  builder_.add_skilltime(skilltime);
  builder_.add_cmboSkillID(cmboSkillID);
  builder_.add_cmboStartFrame(cmboStartFrame);
  builder_.add_sellBarTime(sellBarTime);
  builder_.add_rcoveryFrames(rcoveryFrames);
  builder_.add_activeFrames(activeFrames);
  builder_.add_startUpFrames(startUpFrames);
  builder_.add_totalFrames(totalFrames);
  builder_.add_animationSpeed(animationSpeed);
  builder_.add_iterpolationSpeed(iterpolationSpeed);
  builder_.add_wapMode(wapMode);
  builder_.add_moveName(moveName);
  builder_.add_animationName(animationName);
  builder_.add_fps(fps);
  builder_.add_caracterAsset(caracterAsset);
  builder_.add_dscription(dscription);
  builder_.add_forcey(forcey);
  builder_.add_forcex(forcex);
  builder_.add_hurtPauseTime(hurtPauseTime);
  builder_.add_hurtPause(hurtPause);
  builder_.add_hurtTime(hurtTime);
  builder_.add_hurtType(hurtType);
  builder_.add_hitSFXID(hitSFXID);
  builder_.add_goSFXAsset(goSFXAsset);
  builder_.add_goHitEffectAsset(goHitEffectAsset);
  builder_.add_hitEffect(hitEffect);
  builder_.add_isLoop(isLoop);
  builder_.add_attackSpeed(attackSpeed);
  builder_.add_skillPhases(skillPhases);
  builder_.add_skillPriority(skillPriority);
  builder_.add_skillID(skillID);
  builder_.add__name(_name);
  builder_.add_isUseSelectSeatJoystick(isUseSelectSeatJoystick);
  builder_.add_isSpeicalOperate(isSpeicalOperate);
  builder_.add_isCharge(isCharge);
  builder_.add_notGrabToBlock(notGrabToBlock);
  builder_.add_notUseGrabSetPos(notUseGrabSetPos);
  builder_.add_notGrabGeDang(notGrabGeDang);
  builder_.add_notGrabBati(notGrabBati);
  builder_.add_grabSupportQuickPressDismis(grabSupportQuickPressDismis);
  builder_.add_hitSpreadOut(hitSpreadOut);
  builder_.add_cameraRestore(cameraRestore);
  builder_.add_ueSpellBar(ueSpellBar);
  builder_.add_loopAnimation(loopAnimation);
  builder_.add_notLoopLastFrame(notLoopLastFrame);
  builder_.add_relatedAttackSpeed(relatedAttackSpeed);
  return builder_.Finish();
}

struct FBSkillDataTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *path() const { return GetPointer<const flatbuffers::String *>(4); }
  const flatbuffers::String *type() const { return GetPointer<const flatbuffers::String *>(6); }
  uint8_t isCommon() const { return GetField<uint8_t>(8, 0); }
  const FBSkillData *data() const { return GetPointer<const FBSkillData *>(10); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* path */) &&
           verifier.Verify(path()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* type */) &&
           verifier.Verify(type()) &&
           VerifyField<uint8_t>(verifier, 8 /* isCommon */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* data */) &&
           verifier.VerifyTable(data()) &&
           verifier.EndTable();
  }
};

struct FBSkillDataTableBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_path(flatbuffers::Offset<flatbuffers::String> path) { fbb_.AddOffset(4, path); }
  void add_type(flatbuffers::Offset<flatbuffers::String> type) { fbb_.AddOffset(6, type); }
  void add_isCommon(uint8_t isCommon) { fbb_.AddElement<uint8_t>(8, isCommon, 0); }
  void add_data(flatbuffers::Offset<FBSkillData> data) { fbb_.AddOffset(10, data); }
  FBSkillDataTableBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  FBSkillDataTableBuilder &operator=(const FBSkillDataTableBuilder &);
  flatbuffers::Offset<FBSkillDataTable> Finish() {
    auto o = flatbuffers::Offset<FBSkillDataTable>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<FBSkillDataTable> CreateFBSkillDataTable(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> path = 0,
   flatbuffers::Offset<flatbuffers::String> type = 0,
   uint8_t isCommon = 0,
   flatbuffers::Offset<FBSkillData> data = 0) {
  FBSkillDataTableBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_type(type);
  builder_.add_path(path);
  builder_.add_isCommon(isCommon);
  return builder_.Finish();
}

struct FBSkillDataCollection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::Vector<flatbuffers::Offset<FBSkillDataTable>> *collection() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FBSkillDataTable>> *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* collection */) &&
           verifier.Verify(collection()) &&
           verifier.VerifyVectorOfTables(collection()) &&
           verifier.EndTable();
  }
};

struct FBSkillDataCollectionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_collection(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBSkillDataTable>>> collection) { fbb_.AddOffset(4, collection); }
  FBSkillDataCollectionBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  FBSkillDataCollectionBuilder &operator=(const FBSkillDataCollectionBuilder &);
  flatbuffers::Offset<FBSkillDataCollection> Finish() {
    auto o = flatbuffers::Offset<FBSkillDataCollection>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<FBSkillDataCollection> CreateFBSkillDataCollection(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FBSkillDataTable>>> collection = 0) {
  FBSkillDataCollectionBuilder builder_(_fbb);
  builder_.add_collection(collection);
  return builder_.Finish();
}

inline bool VerifyWeaponClassesOrWhatever(flatbuffers::Verifier &verifier, const void *union_obj, WeaponClassesOrWhatever type) {
  switch (type) {
    case WeaponClassesOrWhatever_NONE: return true;
    case WeaponClassesOrWhatever_boolValue: return verifier.VerifyTable(reinterpret_cast<const boolValue *>(union_obj));
    case WeaponClassesOrWhatever_floatValue: return verifier.VerifyTable(reinterpret_cast<const floatValue *>(union_obj));
    case WeaponClassesOrWhatever_intValue: return verifier.VerifyTable(reinterpret_cast<const intValue *>(union_obj));
    case WeaponClassesOrWhatever_QuaternionValue: return verifier.VerifyTable(reinterpret_cast<const QuaternionValue *>(union_obj));
    case WeaponClassesOrWhatever_uintValue: return verifier.VerifyTable(reinterpret_cast<const uintValue *>(union_obj));
    case WeaponClassesOrWhatever_Vector3Value: return verifier.VerifyTable(reinterpret_cast<const Vector3Value *>(union_obj));
    default: return false;
  }
}

inline const FBSkillData::FBSkillDataCollection *GetFBSkillDataCollection(const void *buf) { return flatbuffers::GetRoot<FBSkillData::FBSkillDataCollection>(buf); }

inline bool VerifyFBSkillDataCollectionBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<FBSkillData::FBSkillDataCollection>(); }

inline const char *FBSkillDataCollectionIdentifier() { return "SKIL"; }

inline bool FBSkillDataCollectionBufferHasIdentifier(const void *buf) { return flatbuffers::BufferHasIdentifier(buf, FBSkillDataCollectionIdentifier()); }

inline void FinishFBSkillDataCollectionBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<FBSkillData::FBSkillDataCollection> root) { fbb.Finish(root, FBSkillDataCollectionIdentifier()); }

}  // namespace FBSkillData

#endif  // FLATBUFFERS_GENERATED_FBSKILLDATA_FBSKILLDATA_H_
