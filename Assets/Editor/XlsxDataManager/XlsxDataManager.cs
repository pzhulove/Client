// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;

using System.IO;
using System.Collections.Generic;

using NPOI.HSSF.UserModel;
using NPOI.SS.UserModel;
using NPOI.XSSF.UserModel;

using UnityEngine;
using UnityEditor;

//using google.protobuf;
//using ProtoBuf;
using System.Reflection;

using System.Xml;
//using ProtoBuf.Meta;

using System.Security.Cryptography;
using System.Text;

public enum DataUnitType
{
    XLS = 0,
    TEXT,
    CSCODE,
    E_CSCODE,
    PROTO,
    XML,
    SERVER_TEXT,
    ASSET,
    CCODE,
};


class XlsxDebug
{
    public static void Log(string log)
    {
        UnityEngine.Debug.Log(log);
    }

    public static void LogError(string log)
    {
        LogErrorFormat(log);
    }

    private static List<string> mCacheErros = new List<string>();

    public static void LogErrorFormat(string format, params object[] args)
    {
        UnityEngine.Debug.LogErrorFormat(format, args);

        mCacheErros.Add(string.Format(format, args));
    }

    public static void PopAllError()
    {
        if (mCacheErros.Count > 0)
        {
            EditorUtility.DisplayDialog("发生错误, 第一个错误", mCacheErros[0], "马上改");
        }

        mCacheErros.Clear();
    }
}

public class DataUnitPath
{
    public static string XLS_PATH = "../Share/table/xls";
    public static string TXET_PATH = "Assets/Resources/Data/table/";
    public static string SERVER_CLIENT_TEXT_PATH = "../Share/table/servertable/";
    public static string SERVER_CLIENT_PROTO_PATH = "../Share/table/serverprotobuf/";
    public static string CSCODE_PATH = "Assets/Scripts/01TableScript/table";
    public static string E_CSCODE_PATH = "Assets/Editor/XlsxDataManager";
    public static string PROTO_PATH = "../Share/table/proto";
    public static string XML_PATH = "../Share/table/xml";
    public static string SERVER_TEXT_PATH = "../Share/table/server";

    public static string CombinePath(string name, DataUnitType type)
    {
        string fullpath = "";
        switch (type)
        {
            case DataUnitType.CSCODE:
                fullpath = Path.Combine(CSCODE_PATH, name + ".cs");
                break;
            case DataUnitType.PROTO:
                fullpath = Path.Combine(PROTO_PATH, name + ".proto");
                break;
            case DataUnitType.E_CSCODE:
                fullpath = Path.Combine(E_CSCODE_PATH, name + ".cs");
                break;
            case DataUnitType.TEXT:
                fullpath = Path.Combine(SERVER_CLIENT_TEXT_PATH, name + ".txt");
                break;
            case DataUnitType.XLS:
                fullpath = Path.Combine(XLS_PATH, name + ".xls");
                break;
            case DataUnitType.ASSET:
                fullpath = Path.Combine(TXET_PATH, name + ".asset");
                break;
            case DataUnitType.XML:
                fullpath = Path.Combine(XML_PATH, name + ".xml");
                break;
            case DataUnitType.SERVER_TEXT:
                fullpath = Path.Combine(SERVER_TEXT_PATH, name + ".txt");
                break;
            case DataUnitType.CCODE:
                fullpath = SERVER_CLIENT_PROTO_PATH;
                break;
            default:
                break;
        }

        return fullpath;
    }

    public static string GetMd5Hash(string path)
    {
        MD5 md5Hash = MD5.Create();
        byte[] data = null;

        using (FileStream fs = File.Open(path, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
        {
            data = md5Hash.ComputeHash(fs);
        }

        StringBuilder sBuilder = new StringBuilder();

        for (int i = 0; i < data.Length; i++)
        {
            sBuilder.Append(data[i].ToString("x2"));
        }

        return sBuilder.ToString().ToLower();
    }

}


public static class XlsxCellUtility
{
    public static int CustomToInt(this ICell cell)
    {
        return Convert.ToInt32(cell.ToString());
    }

    public static int CustomIDToInt(this ICell cell, string type="sint32")
    {
        string cellStr = cell.ToString();
        if (cellStr.Length <= 0)
        {
            XlsxDebug.LogErrorFormat("CustomIDToInt : the string len is 0");
            return 0;
        }

        if ("sint32" == type)
        {
            int value = -1;

            if (int.TryParse(cellStr, out value))
            {
                return value;
            }
            else
            {
                float fv = 0.0f;
                if (float.TryParse(cellStr, out fv))
                {
                    return (int)fv;
                }
                XlsxDebug.LogErrorFormat("convert to number error : {0}", cellStr);
            }

            return value;
        }
        else if ("string" == type)
        {
            return cellStr.GetHashCode();
        }
        else
        {
            XlsxDebug.LogErrorFormat("Error Type With : {0}, {1}", type, cellStr);
            return -1;
        }
    }

    public static string CustomToString(this ICell cell)
    {
        return cell.ToString();
    }

    public static T CustomToEnum<T>(this ICell cell) where T : class
    {
        return cell.CustomToInt() as T;
    }


    public static bool CustomToBool(this ICell cell)
    {
        return cell.CustomToInt() != 0;
    }
}

public class XlsxDataUnit : ICloneable
{
    public List<XlsxDataUnit> mergedSheets = new List<XlsxDataUnit>();

    private static int sDeepLevel = 0;

    private readonly string PROTO_NAMESPACE = "ProtoTable";

    private IRow mHeadRow;
    private IRow mProtoModRow;
    private IRow mProtoKeyRow;
    private IRow mProtoTypeRow;

    // map.key -> ID
    // KV.key -> ItemName
    private Dictionary<int, KeyValuePair<string, List<ProtoXlsxEnumItem>>> mDictHeadKV;

    // KV.key -> ProtoTypeString, KV.Value -> None
    private Dictionary<int, KeyValuePair<string, string>> mDictProtoModKV;

    // KV.key -> ProtoType, KV.Value -> proto dependence
    // KV.key === 'enum' -> check the HeadRow
    private Dictionary<int, KeyValuePair<string, string>> mDictProtoTypeKV;

    // KV.key -> ProtoKeyString, KV.Value -> default value or value range
    private Dictionary<int, KeyValuePair<string, string>> mDictProtoKeyKV;


    private IWorkbook mWorkbook;
    private ISheet mCurSheet;
    // key: ID
    public Dictionary<int, Dictionary<string, ICell>> mDictData;
    // key: Line number
    public Dictionary<int, Dictionary<string, ICell>> mDictDataByLine;
    // key: ID, Line Number
    public Dictionary<int, int> mDictID2Line;

    private Dictionary<string, bool> mDicToggleDic;
    private Dictionary<string, int> mDicToggleCount;

    private Dictionary<string, int> mDicSelectDic;

    private Dictionary<string, int> mDicMask;

    private Dictionary<int, string> mDicIsServer;

    public static bool sDebug = false;

    // ID type string or sint32
    private string mCurIDType = "";

    private string mCurPath = "";
    private string mProtoName = "";

    private string mErrorMsg = "";

    private int mRowCount = 0;
    private int mCellCount = 0;

    private int mKeyIndex = 0;

    private bool mInitFail = false;

    public const string STRING_CELL_DEFAULTE = "-";

    public const char SPLITE_LINE = '\n';
    public const char SPLITE_KEY_VALUE = ':';
    public const char SPLITE_REPEATED = '|';

    private const int PROTO_MOD_ROW_INDEX = 0;
    private const int PROTO_TYPE_ROW_INDEX = 1;
    private const int PROTO_KEY_ROW_INDEX = 2;
    private const int PROTO_SERVER_FLAG = 3;

    public const int XLS_HEAD_INDEX = 4;
    public const int XLS_DATA_INDEX = 5;

    class ProtoXlsxEnumItem
    {
        private string mKey = "";
        private int mValue = 0;
        private string mComment = "";
        private string mType = "";

        private bool mValid = false;

        public string key
        {
            get
            {
                return mKey;
            }
        }

        public int value
        {
            get
            {
                return mValue;
            }
        }

        public string comment
        {
            get
            {
                return mComment;
            }
        }

        public bool valid
        {
            get
            {
                return mValid;
            }
        }

        public string type
        {
            get
            {
                return mType;
            }
        }


        public ProtoXlsxEnumItem(string item)
        {
            string[] enumKVList = item.Split(SPLITE_KEY_VALUE);
            if (enumKVList.Length > 2)
            {
                mValid = true;
                try
                {
                    mKey = enumKVList[0];
                    mValue = int.Parse(enumKVList[1]);
                    mComment = enumKVList[2];
                }
                catch (Exception e)
                {
                    mValid = false;
                    //XlsxDebug.LogErrorFormat("[ProtoXlsxEnumItem] Prase Error : {0}, {1}", item, e.ToString());
                }
            }
            else
            {
                //XlsxDebug.LogWarningFormat("[ProtoXlsxEnumItem] Format Error : {0}", item);
            }
        }

        public bool IsValidEnumItem(string str)
        {
            int intvalue = int.MaxValue;

            try
            {
                intvalue = int.Parse(str);
            }
            catch
            {

            }

            return intvalue == mValue || str == mComment || str == mKey;
        }

        public override string ToString()
        {
            return string.Format("{0}:{1}:{2}", mKey, mValue, mComment);
        }
    };

    public string ProtoName
    {
        get
        {
            return mProtoName;
        }
    }

    public string ErrorMessage
    {
        get
        {
            return mErrorMsg;
        }
    }

    public int RowCount
    {
        get
        {
            return mRowCount;
        }
        set
        {
            mRowCount = value;
        }
    }

    public int CellCount
    {
        get
        {
            return mCellCount;
        }
    }

    public string CurrentPath
    {
        get
        {
            return mCurPath;
        }
    }

    public DateTime LastWriteTime
    {
        get
        {
            return File.GetLastWriteTime(CurrentPath);
        }
    }


    public void SetKeyIndex(string name)
    {
        if (mHeadRow != null)
        {

            mKeyIndex = mHeadRow.Cells.FindIndex(delegate (ICell cell)
                    {
                    return CellType.Numeric == cell.CellType && cell.ToString().Split(SPLITE_LINE)[0] == name;
                    });
        }
        else
        {
            mKeyIndex = 0;
            // TODO warning log
        }
    }

    public string[] GetDependents()
    {
        List<string> depList = new List<string>();
        HashSet<string> depSet = new HashSet<string>();

        for (int i = 0; i < mCellCount; i++)
        {
            string key = mDictProtoTypeKV[i].Value;

            if (!depSet.Contains(key))
            {
                depList.Add(key);
            }
            else
            {
                depSet.Add(key);
            }
        }

        return depList.ToArray();
    }

    public Dictionary<string, ICell> GetRowData(int id)
    {
        Dictionary<string, ICell> reDic = null;

        if (mDictData.ContainsKey(id))
        {
            reDic = mDictData[id];
        }

        return reDic;
    }

    public Dictionary<string, ICell> GetRowDataByLine(int line)
    {
        Dictionary<string, ICell> reDic = null;

        if (mDictDataByLine.ContainsKey(line))
        {
            reDic = mDictDataByLine[line];
        }

        return reDic;
    }

    public int GetLineByID(int id)
    {
        if (mDictID2Line.ContainsKey(id))
        {
            return mDictID2Line[id];
        }

        return -1;
    }

    public void Close()
    {
        if (mWorkbook != null)
        {
            mWorkbook.Close();
        }
    }

    public bool Write()
    {
        if (mWorkbook != null)
        {
            try
            {
                using (FileStream fs = File.OpenWrite(mCurPath))
                {
                    mWorkbook.Write(fs);
                }
                return true;
            }
            catch (Exception)
            {
                XlsxDebug.LogErrorFormat("关闭其他占用 {0} 的程序之后重新保存", mCurPath);
                return false;
            }
        }

        return false;
    }


    public XlsxDataUnit(string filepath)
    {
        mCurPath = filepath;
        try
        {
            using (Stream fs = File.Open(mCurPath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
            {
                _init(fs, mCurPath);
            }
        }
        catch (Exception e)
        {
            //XlsxDebug.LogErrorFormat("[XlsxDataUnit] Open File({0}) Error {1}", m_pCurPath, e.ToString());
            mInitFail = true;
        }
    }

    private void _init(Stream fs, string filePath)
    {

       
        mCurSheet = Xls2FBWindow.GetSheet(filePath, out mWorkbook); 

        mDictData = new Dictionary<int, Dictionary<string, ICell>>();
        mDictDataByLine = new Dictionary<int, Dictionary<string, ICell>>();
        mDictID2Line = new Dictionary<int, int>();

        mDicToggleDic = new Dictionary<string, bool>();
        mDicToggleCount = new Dictionary<string, int>();
        mDicMask = new Dictionary<string, int>();

        mDicIsServer = new Dictionary<int, string>();

        mDicSelectDic = new Dictionary<string, int>();

        mProtoName = mCurSheet.SheetName;

        mErrorMsg = "";

        _generateProtoRow();
        _generateHeadRow();
        _generateDataRow();
        _generateServerRow();

        if (!_isValidXls())
        {
            throw new Exception("XlsxDataUnit Not a Valid Xls");
        }
        mWorkbook.Close();
        fs.Close();
    }

    public XlsxDataUnit()
    { }

    public XlsxDataUnit(Stream fs)
    {
        _init(fs, "");
    }

    public object Clone()
    {
        XlsxDataUnit xlsx = new XlsxDataUnit(mCurPath);
        return xlsx;

        /*
           xlsx.m_pCurPath = m_pCurPath;

           xlsx.m_pWorkbook = new HSSFWorkbook();
           xlsx.m_pCurSheet = m_pWorkbook.CloneSheet(0);
           xlsx.m_pDictData = new Dictionary<int, Dictionary<string, ICell>>();
           xlsx.m_pDictDataByLine = new Dictionary<int, Dictionary<string, ICell>>();
           xlsx.m_pDicToggleDic = new Dictionary<string, bool>();
           xlsx.m_pDicToggleCount = new Dictionary<string, int>();
           xlsx.m_pDicMask = new Dictionary<string, int>();

           xlsx.m_sProtoName = m_pCurSheet.SheetName;

           xlsx.GenerateProtoRow();
           xlsx.GenerateHeadRow();
           xlsx.GenerateDataRow();

           return xlsx;
           */
    }


    private bool _isEmptyRow(int index)
    {
        var cell = mCurSheet.GetRow(index); 
        if (cell == null)
        {
            return true;
        }

        if (cell.GetCell(0) == null)
        {
            return true;
        }

        if (cell.GetCell(0).ToString().Equals(""))
        {
            return true;
        }

        return false;
    }

    static string _Convert2EditorPath(string path)
    {
        string newPath = "Assets/Resources/" + path;

        if (!newPath.EndsWith(".asset"))
        {
            newPath += ".asset";
        }

        return newPath;
    }

    private string _convertAssetIDArray(int id, string typeStr, string config)
    {
        if ("DChapterData" == typeStr)
        {
            string[] allConfig = config.Split('|');
            string ans = "-";

            for (int i = 0; i < allConfig.Length; ++i)
            {
                var newdata = AssetDatabase.LoadAssetAtPath<DChapterData>(_Convert2EditorPath(allConfig[i]));
                if (null != newdata)
                {
                    for (int j = 0; j < newdata.chapterList.Length; ++j)
                    {
                        if (i == 0 && j == 0)
                        {
                            ans = newdata.chapterList[j].dungeonID.ToString();
                        }
                        else
                        {
                            ans += "|" + newdata.chapterList[j].dungeonID.ToString();
                        }
                    }
                }
            }
            return ans;
        }

        var data = AssetDatabase.LoadAssetAtPath<ScriptableObject>(_Convert2EditorPath(config));//, false).obj as ScriptableObject;
        if (data == null)
        {
            if (typeStr == "DChapterData")
            {
                return "-";
            }
            else
            {
                XlsxDebug.LogError("config data is nil " + config);
                return "";
            }
        }

        var dataType = data.GetType();
        if (dataType.Name == "DSceneData")
        {
            //var scenedata = data as DSceneData;
            //var monstlist = scenedata._monsterinfo;
            //var ansStr = "";

            //// id, group, areaid, type, unitid
            //for (int i = 0; i < monstlist.Length; i++)
            //{
            //    ansStr += string.Format("{0}\t{1}\t{2}\t{3}\t{4}", id * 1000 + i, 0, id, 0, monstlist[i].resid);
            //    if (i != monstlist.Length - 1)
            //    {
            //        ansStr += "\n";
            //}
            //}
            //return ansStr;
            return "";
        }
        else if (dataType.Name == "DChapterData")
        {
            var chapterData = data as DChapterData;

            var ans = "";

            if (null != chapterData)
            {
                var list = chapterData.chapterList;

                if (list.Length > 0)
                {
                    ans += list[0].dungeonID.ToString();
                }

                for (int i = 1; i < list.Length; ++i)
                {
                    ans += "|" + list[i].dungeonID.ToString();
                }
                return ans;
            }

            return "-";

        }
        else if (dataType.Name == "DDungeonData")
        {
            var dungeonData = data as DDungeonData;
            var list = _getValidDSceneDataConnnectList(dungeonData);
            //var list = dungeonData.areaconnectlist;

            var flag = false;

            for (int i = 0; i < list.Length; ++i)
            {
                if (list[i].scenedata == null)
                {
                    list[i].scenedata = Resources.Load<DSceneData>(list[i].sceneareapath);
                }
            }

            for (int i = 0; i < list.Length; ++i)
            {
                if (list[i].scenedata == null)
                {
                    XlsxDebug.LogErrorFormat("地下城数据，未指定区域SceneData {0}, {1}", config, i);
                    flag = true;
                }
            }

            if (flag)
            {
                return "";
            }

            string ans = "";
            if (list.Length >= 1)
            {
                ans = _getDSceneDataConnnectServerText(dungeonData, list[0], id % 10);
                //ans = (list[0].id * 10 + id % 10 + 1).ToString();
            }
            for (int i = 1; i < list.Length; ++i)
            {
                ans += string.Format("{0}{1}", SPLITE_REPEATED, _getDSceneDataConnnectServerText(dungeonData, list[i], id % 10)); // (list[i].id * 10 + id % 10 + 1).ToString());
            }

            for (int i = 0; i < dungeonData.areaconnectlist.Length; ++i)
            {
                var unit = dungeonData.areaconnectlist[i];
                if (unit.isstart)
                {
                    ans += string.Format("\t{0}", unit.id * 10 + id % 10 + 1);
                    break;
                }
            }

            for (int i = 0; i < dungeonData.areaconnectlist.Length; ++i)
            {
                var unit = dungeonData.areaconnectlist[i];
                if (unit.isboss)
                {
                    ans += string.Format("\t{0}", unit.id * 10 + id % 10 + 1);
                    break;
                }
            }

            bool hellflag = false;
            for (int i = 0; i < dungeonData.areaconnectlist.Length; ++i)
            {
                var unit = dungeonData.areaconnectlist[i];

                if (!unit.isstart && !unit.isboss && !unit.isnothell)
                {
                    if (!hellflag)
                    {
                        ans += string.Format("\t{0}", unit.id * 10 + id % 10 + 1);
                    }
                    else 
                    {
                        ans += string.Format("{0}{1}", SPLITE_REPEATED, unit.id * 10 + id % 10 + 1);
                    }
                   
                    hellflag = true;
                    //break;
                }
            }

            if (!hellflag)
            {
                ans += "\t0";
            }

            ans += string.Format("\t{0}", _findMiniCost2BossRoom(dungeonData));

            return ans;
        }
        else
        {
            XlsxDebug.LogErrorFormat("config data wrong type {0} at {1}", dataType.Name, config);
            return "";
        }
    }

    private static DSceneDataConnect[] _getValidDSceneDataConnnectList(DDungeonData dungeonData)
    {
        DSceneDataConnect startConnect = null;

        for (int i = 0; i < dungeonData.areaconnectlist.Length; i++)
        {
            DSceneDataConnect conNode = dungeonData.areaconnectlist[i];
            if (null != conNode && conNode.isstart)
            {
                startConnect = conNode;
                break;
            }
        }

        if (null == startConnect)
        {
            return new DSceneDataConnect[0];
        }

        List<DSceneDataConnect> filterList = new List<DSceneDataConnect>();

        Queue<DSceneDataConnect> queue = new Queue<DSceneDataConnect>();

        queue.Enqueue(startConnect);
        filterList.Add(startConnect);

        while (queue.Count > 0)
        {
            DSceneDataConnect curNode = queue.Dequeue();

            int nx = curNode.positionx;
            int ny = curNode.positiony;

            curNode = _findNodeByPostion(dungeonData, nx, ny + 1);
            if (_checkIsValid(filterList, curNode))
            {
                filterList.Add(curNode);
                queue.Enqueue(curNode);
            }
            curNode = _findNodeByPostion(dungeonData, nx, ny - 1);
            if (_checkIsValid(filterList, curNode))
            {
                filterList.Add(curNode);
                queue.Enqueue(curNode);
            }
            curNode = _findNodeByPostion(dungeonData, nx + 1, ny);
            if (_checkIsValid(filterList, curNode))
            {
                filterList.Add(curNode);
                queue.Enqueue(curNode);
            }
            curNode = _findNodeByPostion(dungeonData, nx - 1, ny);
            if (_checkIsValid(filterList, curNode))
            {
                filterList.Add(curNode);
                queue.Enqueue(curNode);
            }
        }

        filterList.Sort((a, b) =>
        {
            return a.areaindex - b.areaindex;
        });

        return filterList.ToArray();
    }

    private static bool _checkIsValid(List<DSceneDataConnect> list, DSceneDataConnect node)
    {
        if (null == node) { return false; }

        return !list.Contains(node);
    }

    private static DSceneDataConnect _findNodeByPostion(DDungeonData data, int posx, int posy)
    {
        if (posx < 0 || posy < 0 || posx >= data.weidth || posy >= data.height)
        {
            return null;
        }

        DSceneDataConnect[] nodes = data.areaconnectlist;

        for (int i = 0; i < nodes.Length; ++i)
        {
            if (nodes[i].positionx == posx && nodes[i].positiony == posy)
            {
                return nodes[i];
            }
        }

        return null;
    }

    private static string _getDSceneDataConnnectServerText(DDungeonData dungeonData, DSceneDataConnect con, int diff)
    {
        if (null == con || null == dungeonData)
        {
            return string.Empty;
        }

        //if (con.linkAreaIndex.Length <= 0)
        //{
        //    return _getDSceneDataConnnectServerText(con, diff);
        //}
        //else
        {
            List<string> list = new List<string>();

            list.Add(_getDSceneDataConnnectServerText(con, diff));

            for (int i = 0; i < con.linkAreaIndex.Length; ++i)
            {
                int linkindex = con.linkAreaIndex[i];
                if (linkindex >= 0 && linkindex < dungeonData.areaconnectlist.Length)
                {
                    list.Add(_getDSceneDataConnnectServerText(dungeonData.areaconnectlist[linkindex], diff));
                }
            }

            return string.Join(",", list.ToArray());
        }
    }

    private static string _getDSceneDataConnnectServerText(DSceneDataConnect con, int diff)
    {
        if (null == con)
        {
            return string.Empty;
        }

        return (con.id * 10 + diff + 1).ToString();
    }

    private int _findMiniCost2BossRoom(DDungeonData dungeonData)
    {
        Queue<int> q = new Queue<int>();

        bool[] flag = new bool[dungeonData.areaconnectlist.Length];
        int[] counts = new int[dungeonData.areaconnectlist.Length];

        for (int i = 0; i < dungeonData.areaconnectlist.Length; ++i)
        {
            var condata = dungeonData.areaconnectlist[i];

            if (condata.isstart)
            {
                q.Enqueue(i);
                counts[i] = 1;
                break;
            }
        }


        int bossIdx = 0;

        for (int i = 0; i < dungeonData.areaconnectlist.Length; ++i)
        {
            var condata = dungeonData.areaconnectlist[i];

            if (condata.isboss)
            {
                bossIdx = i;
                break;
            }
        }

        while (q.Count > 0)
        {
            int idx = q.Dequeue();

            var condata = dungeonData.areaconnectlist[idx];

            for (int i = 0; i < condata.isconnect.Length; ++i)
            {
                if (condata.isconnect[i])
                {
                    var fData = dungeonData.GetSideByType(condata, (TransportDoorType)i);

                    int nextIdx = fData.GetAreaIndex();

                    if (!flag[nextIdx])
                    {
                        counts[nextIdx] = counts[idx] + 1;

                        q.Enqueue(nextIdx);
                    }
                }
            }

            flag[idx] = true;
        }

        return counts[bossIdx];
    }

    private static string[] VALID_MOD_STR = {
        "required",
        "optional",
        "repeated"
    };

    private static string[] VALID_TYPE_STR = {
        "sint32",
        "string",
        "bool",
        "enum",
        "union",
        "float",
        "union(float)",
        "realfloat"
    };

    private static string[] VALID_ID_TYPE_STR = {
        "sint32",
        "string",
    };



    private bool _isValidProtoCell(string cellString, string[] array)
    {
        foreach (string item in array)
        {
            if (item == cellString)
            {
                return true;
            }
        }

        XlsxDebug.LogErrorFormat("Table {0} : Type Must Be {1} ({2}) ", mProtoName, string.Join(",", array), cellString);

        return false;
    }

    private bool _isValidTypeName(string typeName, ref Dictionary<string, int> typeNameDict, int idx = 0)
    {
        if (typeName.Length <= 0)
        {
            XlsxDebug.LogErrorFormat("[IsValidTypeName] : 表 {0}, 第 {1} 列 类型名为空", mProtoName, idx);
            return false;
        }

        if (typeNameDict.ContainsKey(typeName))
        {
            XlsxDebug.LogErrorFormat("[IsValidTypeName] : 表 {0}, 第 {1} 列 类型名字与 第 {2} 列({3})相同", mProtoName, idx, typeNameDict[typeName], typeName);
            return false;
        }
        else
        {
            typeNameDict.Add(typeName, idx);
            return true;
        }
    }

    private bool _isValidRow(IRow row, int idx)
    {
        ICell fstCell = row.GetCell(0);
        ICell sndCell = row.GetCell(1);

        if (fstCell == null || sndCell == null)
        {
            XlsxDebug.LogErrorFormat("[IsValidRow] : 表 {0}, 第 {1} 行， 第一第二列数据无效，请检查数据表", mProtoName, idx);
            return false;
        }

        return true;
    }

    private bool _isValidXls()
    {
        string curCellStr = "";

        Dictionary<string, int> typeNameDict = new Dictionary<string, int>();
        typeNameDict.Clear();

        for (int i = 0; i < mCellCount; i++)
        {
            curCellStr = mDictProtoModKV[i].Key;
            if (!_isValidProtoCell(curCellStr, VALID_MOD_STR))
            {
                return false; 
            }

            curCellStr = mDictProtoTypeKV[i].Key;
            if (!_isValidProtoCell(curCellStr, VALID_TYPE_STR))
            {
                return false;
            }

            curCellStr = mDictProtoKeyKV[i].Key;
            if (!_isValidTypeName(curCellStr, ref typeNameDict, i))
            {
                return false;
            }
        }


        for (int i = XLS_DATA_INDEX; i < mRowCount; i++)
        {
            IRow row = mCurSheet.GetRow(i);
            _isValidRow(row, i);
        }

        return true;
    }

    public void GetCSCode()
    {
        string protoPath = DataUnitPath.CombinePath(mProtoName, DataUnitType.PROTO);//.PROTO_PATH, m_szProtoName);
        string codePath = DataUnitPath.CombinePath(mProtoName, DataUnitType.CSCODE);
        string codecPath = DataUnitPath.CombinePath(mProtoName, DataUnitType.CCODE);

        //ProtoBuf.CodeGenerator.CommandLineOptions.BuildXsxl2Cs(protoPath, codePath, codecPath);
        AssetDatabase.ImportAsset(codePath);

        XlsxDebug.Log("[GetCSCode] : " + Path.GetFullPath(protoPath) + " -> " + Path.GetFullPath(codePath));

		using (FileStream fsRead = File.Open(codePath, FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.ReadWrite))
            {
                int fsLen = (int)fsRead.Length;
                byte[] heByte = new byte[fsLen];
                int r = fsRead.Read(heByte, 0, heByte.Length);
                string myStr = System.Text.Encoding.UTF8.GetString(heByte);

                StringBuilder sbr = new StringBuilder(myStr);

                string str = "#if !USE_FB_TABLE";
                string str2 = "\n#endif";
                if (!myStr.Contains(str))
                {
                    sbr.Insert(0, str);
                    sbr.Append(str2);
                }

                byte[] myByte = System.Text.Encoding.UTF8.GetBytes(sbr.ToString());
                fsRead.Seek(0, SeekOrigin.Begin);
                fsRead.Write(myByte, 0, myByte.Length);

                heByte = null;
                myByte = null;
            }
    }

    public void GetCPPCode()
    {

    }

    private Dictionary<int, KeyValuePair<string, string>> _generateKeyValueDic(IRow row)
    {
        var kvDic = new Dictionary<int, KeyValuePair<string, string>>();
        for (int i = 0; i < row.Cells.Count; i++)
        {
            ICell cell = row.GetCell(i);
            if (cell == null || cell.ToString() == "")
            {
                string errorMsg = string.Format("[GenerateKeyValueDic] : 表 {0}, 第 {1} 列, 数据为空, 行首部数据 {2}", mProtoName, i, row.GetCell(0).ToString());
                XlsxDebug.LogErrorFormat(errorMsg);
                mErrorMsg += string.Format("第 {0} 列, 数据为空\n", i);
                break;
            }

            string[] kvList = cell.ToString().Split(SPLITE_KEY_VALUE);
            string key = kvList[0];
            string value = kvList.Length > 1 ? kvList[1] : "";
            kvDic.Add(i, new KeyValuePair<string, string>(key.Trim(), value.Trim()));
        }

        return kvDic;
    }
    private Dictionary<int, KeyValuePair<string, List<ProtoXlsxEnumItem>>> _generateKeyValueList(IRow row)
    {
        var listDic = new Dictionary<int, KeyValuePair<string, List<ProtoXlsxEnumItem>>>();

        for (int i = 0; i < row.Cells.Count; i++)
        {
            ICell cell = row.GetCell(i);
            string[] listList = cell.ToString().Split(SPLITE_LINE);
            string key = listList[0].Trim();
            List<ProtoXlsxEnumItem> protoXlsxEnumList = new List<ProtoXlsxEnumItem>();

            for (int j = 1; j < listList.Length; j++)
            {
                ProtoXlsxEnumItem item = new ProtoXlsxEnumItem(listList[j]);
                if (item.valid)
                {
                    protoXlsxEnumList.Add(item);
                }
            }

            listDic.Add(i, new KeyValuePair<string, List<ProtoXlsxEnumItem>>(key, protoXlsxEnumList));
        }

        return listDic;
    }

    private void _generateHeadRow()
    {
        mHeadRow = mCurSheet.GetRow(XLS_HEAD_INDEX);
        mDictHeadKV = _generateKeyValueList(mHeadRow);
    }

    private void _generateProtoRow()
    {
        mProtoModRow = mCurSheet.GetRow(PROTO_MOD_ROW_INDEX);
        mDictProtoModKV = _generateKeyValueDic(mProtoModRow);

        mProtoTypeRow = mCurSheet.GetRow(PROTO_TYPE_ROW_INDEX);
        mDictProtoTypeKV = _generateKeyValueDic(mProtoTypeRow);

        mCurIDType = mDictProtoTypeKV[0].Key.ToString();

        mProtoKeyRow = mCurSheet.GetRow(PROTO_KEY_ROW_INDEX);
        mDictProtoKeyKV = _generateKeyValueDic(mProtoKeyRow);

        mCellCount = mDictProtoModKV.Count;
    }


    public string ProtoClassName
    {
        get
        {
            return string.Format("{0}.{1}", PROTO_NAMESPACE, mProtoName);
        }
    }


    private string _getProtoEnumString(string name, List<ProtoXlsxEnumItem> list)
    {
        string enumStr = "enum " + name + "\n";

        enumStr += "{\n";
        foreach (var item in list)
        {
            // key = value; // comment
            enumStr += string.Format("\t{0} = {1}; // {2}\n", item.key, item.value, item.comment);
        }
        enumStr += "}\n";

        return enumStr;
    }

    //private bool mIsUpdatedProto = false;
    public bool GetProto()
    {
        string import = "import \"Union.proto\";\n\n";

        bool unionFlag = false;

        for (int i = 0; i < mCellCount; i++)
        {
            string typeStr = mDictProtoTypeKV[i].Key;
			if (typeStr == "union" || typeStr == "union(float)")
            {
                unionFlag = true;
                break;
            }
        }

        string protoStr = "";

        if (unionFlag)
            protoStr = import;

        protoStr += string.Format("package {0};\n", PROTO_NAMESPACE);

        protoStr += "message " + mProtoName + "\n";
        protoStr += "{" + "\n";
        for (int i = 0; i < mCellCount; i++)
        {
            // get the own enum
            string modStr = mDictProtoModKV[i].Key;
            string typeStr = mDictProtoTypeKV[i].Key;
            string keyStr = mDictProtoKeyKV[i].Key;

            if (typeStr == "enum")
            {
                typeStr = "e" + keyStr;
                protoStr += _getProtoEnumString(typeStr, mDictHeadKV[i].Value);
            }
            else if (typeStr == "union" || typeStr == "union(float)")
            {
                typeStr = "UnionCell";
            }
            else if (typeStr == "float")
            {
                typeStr = "sint32";
            }
            else if (typeStr == "realfloat")
            {
                typeStr = "float";
            }

            if (keyStr == "ID")
            {
                typeStr = "sint32";
            }

            protoStr += string.Format("{0} {1} {2} = {3};\n",
                    modStr,
                    typeStr,
                    keyStr,
                    i + 1);
        }
        protoStr += "};\n";

        XlsxDebug.Log("[GetProto] " + protoStr);

        string protoPath = DataUnitPath.CombinePath(mProtoName, DataUnitType.PROTO);

        File.WriteAllText(protoPath, protoStr);

        bool updated = false;
        string hash = EditorPrefs.GetString(string.Format("MD5_{0}", mProtoName));

        if (DataUnitPath.GetMd5Hash(protoPath) == hash)
        {
            updated = false;
        }
        else
        {
            updated = true;
            EditorPrefs.SetString(string.Format("MD5_{0}", mProtoName), DataUnitPath.GetMd5Hash(protoPath));
        }

        return updated;
    }

    public string[] GetKeyNameList()
    {
        List<string> knList = new List<string>();

        for (int i = XLS_DATA_INDEX; i < mRowCount; i++)
        {
            IRow curRow = mCurSheet.GetRow(i);
            ICell idCell = curRow.GetCell(0);
            ICell sndCell = curRow.GetCell(1);
            if (_isValidRow(curRow, i))
            {
                knList.Add(string.Format("{0}({1})", idCell.ToString(), sndCell.ToString()));
            }
        }

        return knList.ToArray();
    }

    private object _getCellValueObject(ICell cell, string defaultStr)
    {
        object obj = defaultStr;

        if (cell != null)
        {
            switch (cell.CellType)
            {
                case CellType.Numeric:
                    obj = cell.NumericCellValue;
                    break;
                case CellType.String:
                    obj = cell.StringCellValue;
                    break;
                case CellType.Blank:
                    obj = defaultStr;
                    break;
                case CellType.Formula:
                    try
                    {
                        obj = (int)cell.NumericCellValue;
                    }
                    catch 
                    {
                        XlsxDebug.LogErrorFormat("[GenerateText] 公式转换出错");
                        XlsxDebug.LogErrorFormat("[GenerateText] cell type is not valid {0}, {1}, [{2}行, {3}列]", mProtoName, cell.CellType.ToString(), cell.RowIndex + 1, cell.ColumnIndex);
                    }
                    break;
                default:
                    XlsxDebug.LogErrorFormat("[GenerateText] 数据非法 {0}, {1}, [{2}行, {3}列]", mProtoName, cell.CellType.ToString(), cell.RowIndex + 1, cell.ColumnIndex);

                    break;
            }
        }
        return obj;
    }

    private int _convertToInt(string value, bool isFloat = false)
    {
        return isFloat ? (int)(Convert.ToDouble(value) * 1000) : Convert.ToInt32(value);
    }

    private object _constructUnionCell(string content, bool isFloat = false)
    {
        const string FIX_EVERY_SPLIT = ",";
        const string FIX_GROW_SPLIT = ";";

        ProtoTable.UnionCell unionCell = new ProtoTable.UnionCell();
#if !USE_FB_TABLE
        if (content.Contains(FIX_EVERY_SPLIT))
        {
            unionCell.valueType = ProtoTable.UnionCellType.union_everyvalue;
            ProtoTable.EveryValue values = new ProtoTable.EveryValue();

            var stringValues = content.Split(FIX_EVERY_SPLIT[0]);
            foreach(var sv in stringValues)
            {
                values.everyValues.Add(_convertToInt(sv, isFloat));
            }

            unionCell.eValues = values;
        }
        else if (content.Contains(FIX_GROW_SPLIT))
        {
            unionCell.valueType = ProtoTable.UnionCellType.union_fixGrow;

            var stringValues = content.Split(FIX_GROW_SPLIT[0]);
            if (stringValues.Length != 2)
            {
                XlsxDebug.LogErrorFormat("[GenerateText] union 格式错误 {0}", content);
                return null;
            }

            unionCell.fixInitValue = _convertToInt(stringValues[0], isFloat);
            unionCell.fixLevelGrow = _convertToInt(stringValues[1], isFloat);
        }
        else
        {
            unionCell.valueType = ProtoTable.UnionCellType.union_fix;
            unionCell.fixValue = _convertToInt(content, isFloat);
        }

#endif
        return (object)(unionCell);
    }

    private object _getProtoObject(int idx, string value, string protoType, string defaultValue, string key = "")
    {
        object obj = new object();

        if (key == "ID" && protoType == "string")
        {
            obj = value.GetHashCode();
            return obj;
        }

        if (protoType == "enum")
        {
            var list = mDictHeadKV[idx].Value;

            var result = int.MaxValue;
            if (defaultValue != null && defaultValue.Length > 0)
            {
                foreach (var item in list)
                {
                    if (item.IsValidEnumItem(defaultValue))
                    {
                        result = item.value;
                        break;
                    }
                }
            }

            string str = "";
            foreach (var item in list)
            {
                str += "," + item.ToString();
                if (item.IsValidEnumItem(value))
                {
                    result = item.value;
                    break;
                }
            }

            if (result == int.MaxValue)
            {
                var errorMsg = string.Format("枚举类型未定 {0}, 不在范围内 {1}", value, str);
                XlsxDebug.LogErrorFormat(errorMsg);
                throw new Exception(errorMsg);
            }

            obj = result;
        }
        else if (protoType == "sint32")
        {
            int result = 0;
            // we must make sure the defaulte Value is valid
            if (defaultValue != null && defaultValue.Length > 0)
            {
                try
                {
                    result = int.Parse(defaultValue);
                }
                catch
                {
                }
            }

            try
            {
                result = int.Parse(value);
            }
            catch
            {
            }

            obj = result;
        }
        else if (protoType == "string")
        {
            obj = value;
        }
        else if (protoType == "bool")
        {
            var resulte = 0;
            try
            {
                resulte = int.Parse(value);
            }
            catch
            {
            }

            obj = resulte != 0;
        }
        else if (protoType == "union" || protoType == "union(float)")
        {
            if (value == "-" || value == "")
            {
                value = "0";
            }

            obj = _constructUnionCell(value, protoType == "union(float)");
        }
        else if (protoType == "float")
        {
            float tmpValue = 0;

            try
            {
                tmpValue = float.Parse(value);
            }
            catch
            {
            }

            tmpValue *= 1000;
            obj = (int)tmpValue;
        }
        else if (protoType == "realfloat")
        {
            float tmpValue = 0f;
            try
            {
                tmpValue = float.Parse(value);
            }
            catch
            {

            }
            obj = tmpValue;
        }
        return obj;
    }

    StringBuilder mStringBuilder = StringBuilderCache.Acquire(2000);

    public bool NeedConverServerText()
    {
        return mDicIsServer.Count > 0;
    }

    protected void _getServerText(StreamWriter serverfs)
    {
        Dictionary<string, ICell> reDic = null;

        for (int i = XLS_DATA_INDEX; i < mRowCount; i++)
        {
            //Profiler.BeginSample("OneRowCount");

            mStringBuilder.Clear();

            reDic = GetRowDataByLine(i);

            if (reDic == null)
            {
                XlsxDebug.LogErrorFormat("[GenerateText] 第 {0} 行 数据为空！", i);
                continue;
            }

            object obj = new object();

            bool bFlagServer = false;
            bool bFlagValidData = false;
            bool bFirst = true;
            for (int idx = 0; idx < mCellCount; idx++)
            {
                if (!mDicIsServer.ContainsKey(idx))
                    continue;

                ICell curCell = null;
                //string key = mDictHeadKV[idx].Key; //m_pHeadRow.GetCell(idx).StringCellValue.Split(SPLITE_LINE)[0].Trim();
                string protoKey = mDictProtoKeyKV[idx].Key; //protoKeyStrList[0].Trim();
                string key = protoKey;
                string protoMod = mDictProtoModKV[idx].Key;
                string protoKeyDefaultStr = mDictProtoKeyKV[idx].Value;//protoKeyStrList.Length > 1 ? protoKeyStrList[1] : "";
                string protoType = mDictProtoTypeKV[idx].Key;//m_pProtoTypeRow.GetCell(idx).StringCellValue.Trim();
                object protoKeyDefaultObj = new object();


                if (reDic.ContainsKey(key))
                {
                    curCell = reDic[key];
                }
                else
                {
                    XlsxDebug.LogErrorFormat("[GenerateText] 请保证数据完整，使用默认值替代");
                    XlsxDebug.LogErrorFormat("[GenerateText] {0} {1}:{2} key: {3}({4}) (type:{5}) ERROR DATA, set default value \"{6}\"", mProtoName, i + 1, idx + 1, protoKey, key, protoType, protoKeyDefaultStr);
                }

                /**
                 * TODO framework refact!!!!!!
                 */
                if (curCell == null && mDicIsServer.ContainsKey(idx))
                {
                    if (bFirst)
                    {
                        mStringBuilder.Append("");
                        //serverTextContent += "";
                        bFirst = false;
                    }
                    else
                    {
                        mStringBuilder.Append("\t");
                        //serverTextContent += "\t" + "";
                    }

                    continue;
                }

                obj = _getCellValueObject(curCell, protoKeyDefaultStr);

                if (mDicIsServer.ContainsKey(idx))
                {
                    //Profiler.BeginSample("Server String Format");
                    bFlagServer = true;
                    string concatStr = "";
                    string dataType = mDicIsServer[idx];
                    if (dataType.Length > 0)
                    {
                        concatStr = _convertAssetIDArray(reDic["ID"].CustomIDToInt(), dataType, obj.ToString());
                    }
                    else
                    {
                        concatStr = obj.ToString();
                    }

                    if (protoType == "float")
                    {
                        if (protoMod == "repeated")
                        {

                            bool isFirst = true;
                            concatStr = "";
                            if (obj.ToString().Length > 0)
                            {
                                foreach (string item in obj.ToString().Split(SPLITE_REPEATED))
                                {

                                    float tmpValue = 0f;
                                    try
                                    {
                                        tmpValue = float.Parse(item);
                                    }
                                    catch
                                    {

                                    }

                                    tmpValue *= 1000;
                                    if (isFirst)
                                    {
                                        isFirst = false;
                                    }
                                    else
                                    {
                                        concatStr += SPLITE_REPEATED;
                                    }

                                    concatStr += ((int)tmpValue).ToString();
                                }
                            }
                        }
                        else
                        {
                            if (concatStr.Length > 0)
                            {
                                float tmpValue = 0f;
                                try
                                {
                                    tmpValue = float.Parse(concatStr);
                                }
                                catch
                                {

                                }

                                tmpValue *= 1000;
                                concatStr = ((int)tmpValue).ToString();
                            }
                        }
                    }

                    if (concatStr.Length > 0)
                    {
                        bFlagValidData = true;
                    }

                    if (bFirst)
                    {
                        mStringBuilder.Append(concatStr);
                        //serverTextContent += concatStr;
                        bFirst = false;
                    }
                    else
                    {
                        mStringBuilder.Append("\t");
                        mStringBuilder.Append(concatStr);
                        //serverTextContent += "\t" + concatStr;
                    }

                    //Profiler.EndSample();
                }
            }

            if (bFlagServer && bFlagValidData)
            {
                //serverTextContent += "\n";
                //mStringBuilder.Append();
                //Profiler.BeginSample("Server Text Write");
                try
                {
                  //  isServerEmpty = false;
                    mStringBuilder.Append("\n");

                    serverfs.Write(mStringBuilder.ToString());
                }
                catch (Exception e)
                {

                    XlsxDebug.LogError("[GenerateText] Write Server With Error : " + e.ToString());
                    XlsxDebug.LogErrorFormat("[GenerateText] Write Server With Error with Line {0}", i);
                }
                //Profiler.EndSample();
            }
        }

    }

    public void GetServerText()
    {
        string serverTextPath = DataUnitPath.CombinePath(mProtoName, DataUnitType.SERVER_TEXT);

        if (File.Exists(serverTextPath))
        {
            File.Delete(serverTextPath);
        }

        StreamWriter serverfs = new StreamWriter(serverTextPath);

        _getServerText(serverfs);
        foreach(var unit in mergedSheets)
        {
            unit._getServerText(serverfs);
        }

     //   bool isServerEmpty = true;



        // if (RowCount < XLS_DATA_INDEX)
        // {
        //     XlsxDebug.LogErrorFormat("[GenerateText] LoadXlsx Error : {0}, {1}", mProtoName, this.mCurPath);
        // }
        // else
        // {
        //     XlsxDebug.Log("[GenerateText] LoadXlsx The Line Count : " + (RowCount - XLS_DATA_INDEX));
        // }

        serverfs.Close();

        // if (isServerEmpty && File.Exists(serverTextPath))
        // {
        //     File.Delete(serverTextPath);
        // }

        XlsxDebug.PopAllError();

        //Profiler.EndSample();
        //Profiler.BeginSample("refresh");
        //AssetDatabase.ImportAsset(textPath);
        //Profiler.EndSample();
    }


    public void GetText()
    {
        string classname = ProtoClassName;

        string textPath = DataUnitPath.CombinePath(mProtoName, DataUnitType.TEXT);
        string serverTextPath = DataUnitPath.CombinePath(mProtoName, DataUnitType.SERVER_TEXT);

        Dictionary<string, ICell> reDic = null;

        if (File.Exists(textPath))
        {
            File.Delete(textPath);
        }

        if (File.Exists(serverTextPath))
        {
            File.Delete(serverTextPath);
        }

        TextDataStream ws = new TextDataStream(textPath);
        StreamWriter serverfs = new StreamWriter(serverTextPath);

        bool isServerEmpty = true;

        for (int i = XLS_DATA_INDEX; i < mRowCount; i++)
        {
            //Profiler.BeginSample("OneRowCount");

            mStringBuilder.Clear();

            Assembly ass = Assembly.GetAssembly(typeof(Utility));
            object tableunit = ass.CreateInstance(classname); ;


            Type type = tableunit.GetType();
            object obj = new object();

            reDic = GetRowDataByLine(i);

            if (reDic == null)
            {
                XlsxDebug.LogErrorFormat("[GenerateText] 第 {0} 行 数据为空！", i);
                continue;
            }

            bool bFlagServer = false;
            bool bFlagValidData = false;
            bool bFirst = true;
            for (int idx = 0; idx < mCellCount; idx++)
            {
                ICell curCell = null;
                //string key = mDictHeadKV[idx].Key; //m_pHeadRow.GetCell(idx).StringCellValue.Split(SPLITE_LINE)[0].Trim();
                string protoKey = mDictProtoKeyKV[idx].Key; //protoKeyStrList[0].Trim();
                string key = protoKey;
                string protoMod = mDictProtoModKV[idx].Key;
                string protoKeyDefaultStr = mDictProtoKeyKV[idx].Value;//protoKeyStrList.Length > 1 ? protoKeyStrList[1] : "";
                string protoType = mDictProtoTypeKV[idx].Key;//m_pProtoTypeRow.GetCell(idx).StringCellValue.Trim();
                object protoKeyDefaultObj = new object();


                if (reDic.ContainsKey(key))
                {
                    curCell = reDic[key];
                }
                else
                {
                    XlsxDebug.LogErrorFormat("[GenerateText] 请保证数据完整，使用默认值替代");
                    XlsxDebug.LogErrorFormat("[GenerateText] {0} {1}:{2} key: {3}({4}) (type:{5}) ERROR DATA, set default value \"{6}\"", mProtoName, i + 1, idx + 1, protoKey, key, protoType, protoKeyDefaultStr);
                }

                /**
                 * TODO framework refact!!!!!!
                 */
                if (curCell == null && mDicIsServer.ContainsKey(idx))
                {
                    if (bFirst)
                    {
                        mStringBuilder.Append("");
                        //serverTextContent += "";
                        bFirst = false;
                    }
                    else
                    {
                        mStringBuilder.Append("\t");
                        //serverTextContent += "\t" + "";
                    }

                    continue;
                }

                obj = _getCellValueObject(curCell, protoKeyDefaultStr);
                PropertyInfo proInfo = type.GetProperty(protoKey, BindingFlags.Public | BindingFlags.Instance);

                if (mDicIsServer.ContainsKey(idx))
                {
                    //Profiler.BeginSample("Server String Format");
                    bFlagServer = true;
                    string concatStr = "";
                    string dataType = mDicIsServer[idx];
                    if (dataType.Length > 0)
                    {
                        concatStr = _convertAssetIDArray(reDic["ID"].CustomIDToInt(), dataType, obj.ToString());
                    }
                    else
                    {
                        concatStr = obj.ToString();
                    }

                    if (protoType == "float")
                    {
                        if (protoMod == "repeated")
                        {

                            bool isFirst = true;
                            concatStr = "";
                            if (obj.ToString().Length > 0)
                            {
                                foreach (string item in obj.ToString().Split(SPLITE_REPEATED))
                                {

                                    float tmpValue = 0f;
                                    try
                                    {
                                        tmpValue = float.Parse(item);
                                    }
                                    catch
                                    {

                                    }

                                    tmpValue *= 1000;
                                    if (isFirst)
                                    {
                                        isFirst = false;
                                    }
                                    else
                                    {
                                        concatStr += SPLITE_REPEATED;
                                    }

                                    concatStr += ((int)tmpValue).ToString();
                                }
                            }
                        }
                        else
                        {
                            if (concatStr.Length > 0)
                            {
                                float tmpValue = 0f;
                                try
                                {
                                    tmpValue = float.Parse(concatStr);
                                }
                                catch
                                {

                                }

                                tmpValue *= 1000;
                                concatStr = ((int)tmpValue).ToString();
                            }
                        }
                    }

                    if (concatStr.Length > 0)
                    {
                        bFlagValidData = true;
                    }

                    if (bFirst)
                    {
                        mStringBuilder.Append(concatStr);
                        //serverTextContent += concatStr;
                        bFirst = false;
                    }
                    else
                    {
                        mStringBuilder.Append("\t");
                        mStringBuilder.Append(concatStr);
                        //serverTextContent += "\t" + concatStr;
                    }

                    //Profiler.EndSample();
                }

                if (protoMod == "repeated")
                {
                    proInfo.GetValue(tableunit, null);

                    object theList = proInfo.GetValue(tableunit, null);
                    string tmpString = obj.ToString();

                    if (!string.IsNullOrEmpty(tmpString.Trim()))
                    {
                        foreach (string item in tmpString.Split(SPLITE_REPEATED))
                        {
                            //objList.Add();
                            try
                            {
                                object addobj = _getProtoObject(idx, item, protoType, protoKeyDefaultStr);
                                theList.GetType().InvokeMember("Add", BindingFlags.Public | BindingFlags.InvokeMethod, null, theList, new object[] { addobj });
                            }
                            catch (Exception)
                            {
                                XlsxDebug.LogErrorFormat("[GenerateText] 转表失败，请保证协议(*.cs)和表格数据(*.xls)相对应");
                                XlsxDebug.LogErrorFormat("[GenerateText] {0} : {1}, {2}, {3}", protoMod, item, protoType, protoKeyDefaultStr);
                                XlsxDebug.LogErrorFormat("[GenerateText] {0} {1}:{2} key: {3}({4}) (type:{5}) ERROR DATA", mProtoName, i + 1, idx + 1, protoKey, key, protoType);
                            }
                        }
                    }
                }
                else
                {
                    try
                    {
                        obj = _getProtoObject(idx, obj.ToString(), protoType, protoKeyDefaultStr, key);
                        proInfo.SetValue(tableunit, obj, null);
                    }
                    catch (Exception e)
                    {
                        XlsxDebug.LogErrorFormat("[GenerateText] 转表失败，请保证协议(*.cs)和表格数据(*.xls)相对应");
                        XlsxDebug.LogErrorFormat("[GenerateText] {0} {1}:{2} key: {3}({4}) (type:{5}) ERROR DATA", mProtoName, i + 1, idx + 1, protoKey, key, protoType);
                        XlsxDebug.LogErrorFormat("[GenerateText] {0}, {1}, {2}, {3}", protoMod, obj.ToString(), protoType, protoKeyDefaultStr);
                        XlsxDebug.LogErrorFormat("[GenerateText] error : {0}", e.ToString());
                    }
                }
            }

            if (bFlagServer && bFlagValidData)
            {
                //serverTextContent += "\n";
                //mStringBuilder.Append();
                //Profiler.BeginSample("Server Text Write");
                try
                {
                     isServerEmpty = false;
                    mStringBuilder.Append("\n");

                    serverfs.Write(mStringBuilder.ToString());




                }
                catch (Exception e)
                {

                    XlsxDebug.LogError("[GenerateText] Write Server With Error : " + e.ToString());
                    XlsxDebug.LogErrorFormat("[GenerateText] Write Server With Error with Line {0}", i);
                }
                //Profiler.EndSample();
            }

            try
            {
                ws.Write(tableunit);
            }
            catch (Exception e)
            {
                XlsxDebug.LogError("[GenerateText] Write With Error : " + e.ToString());
                XlsxDebug.LogErrorFormat("[GenerateText] Write With Error with Line {0}", i);
            }

            //Profiler.EndSample();
        }

        //Profiler.BeginSample("write file");

        if (RowCount < XLS_DATA_INDEX)
        {
            XlsxDebug.LogErrorFormat("[GenerateText] LoadXlsx Error : {0}, {1}", mProtoName, this.mCurPath);
        }
        else
        {
            XlsxDebug.Log("[GenerateText] LoadXlsx The Line Count : " + (RowCount - XLS_DATA_INDEX));
            XlsxDebug.Log("[GenerateText] LoadXlsx The New Text Path : " + textPath);
        }

        ws.Close();
        serverfs.Close();

        string assetPath = DataUnitPath.CombinePath(mProtoName, DataUnitType.ASSET);

        string targetBytes = Path.ChangeExtension(HeroGo.UtilityTools.GetRawResPathOutOfUnity(assetPath), "bytes");
        if (File.Exists(targetBytes))
        {
            File.Delete(targetBytes);
        }

        File.Copy(textPath, targetBytes);

        if (File.Exists(textPath))
        {
            AssetBinary asset = ScriptableSingleton<AssetBinary>.CreateInstance<AssetBinary>();
            //string assetPath = DataUnitPath.CombinePath(mProtoName, DataUnitType.ASSET);
            asset.m_DataBytes = File.ReadAllBytes(textPath);

            if (File.Exists(assetPath))
            {
                //File.Delete(assetPath);
                AssetBinary origin = AssetDatabase.LoadAssetAtPath<AssetBinary>(assetPath);
                origin.m_DataBytes = asset.m_DataBytes;
                EditorUtility.SetDirty(origin);
                AssetDatabase.SaveAssets();
            }
            else
            {
                AssetDatabase.CreateAsset(asset, assetPath);
            }
        }

        if (isServerEmpty && File.Exists(serverTextPath))
        {
            File.Delete(serverTextPath);
        }

        XlsxDebug.PopAllError();
  
        //Profiler.EndSample();
        //Profiler.BeginSample("refresh");
        //AssetDatabase.ImportAsset(textPath);
        //Profiler.EndSample();
    }


    private void _generateServerRow()
    {
        IRow rowData = mCurSheet.GetRow(PROTO_SERVER_FLAG);

        if (rowData == null)
        {
            return;
        }

        for (int i = 0; i < mCellCount; i++)
        {
            ICell cell = rowData.GetCell(i);

            if (cell != null)
            {
                var array = cell.ToString().Trim().Split(SPLITE_KEY_VALUE);

                if (array[0] == "1")
                {
                    if (!mDicIsServer.ContainsKey(i))
                    {
                        mDicIsServer.Add(i, array.Length > 1 ? array[1] : "");
                    }
                    else
                    {
                        XlsxDebug.LogError("already has the key {0}");
                    }
                }
            }
        }
    }

    private void _generateDataRow()
    {
        IRow rowData = null;
        int i;

        for (i = XLS_DATA_INDEX; !_isEmptyRow(i); i++)
        {
            Dictionary<string, ICell> kvData = new Dictionary<string, ICell>();

            rowData = mCurSheet.GetRow(i);

            if (!_isValidRow(rowData, i))
            {
                continue;
            }

            kvData.Clear();

            for (int j = 0; j < mCellCount; j++)
            {
                string key = mDictHeadKV[j].Key;
                string enKey = mDictProtoKeyKV[j].Key;

                ICell cv = rowData.GetCell(j);
                if (!kvData.ContainsKey(enKey))
                {
                    kvData.Add(enKey, cv);
                }

                if (mDictProtoKeyKV.ContainsKey(j))
                {
                    if (!kvData.ContainsKey(enKey))
                    {
                        kvData.Add(enKey, cv);
                    }
                }
            }

            int ikey = kvData["ID"].CustomIDToInt(mCurIDType);

            if (!mDictData.ContainsKey(ikey))
            {
                mDictData.Add(ikey, kvData);
                mDictDataByLine.Add(i, kvData);
                mDictID2Line.Add(ikey, i - XLS_DATA_INDEX);
            }
            else
            {
                XlsxDebug.LogErrorFormat("存在重复ID {0},ID {1} 第 {2} 行与 {3} 重复", mProtoName, ikey, i + 1, mDictID2Line[ikey] + XLS_DATA_INDEX + 1);
                throw new Exception("存在重复ID");
            }

            mRowCount = i + 1;
        }
    }

    //private List<KeyValuePair<string, bool>> m_pCurSplitList = new List<KeyValuePair<string, bool>>();
    private Dictionary<string, bool> m_pDictSplitItem = new Dictionary<string, bool>();

    private string _getLabelName(string label, string debuginfo) 
    {
        if (sDebug)
        {
            label = string.Format("{0}({1}):", label, debuginfo);
        }

        return label;
    }

    public bool IsValid
    {
        get
        {
            return !mInitFail;
        }
    }

#region GUI Update
    private int _onGUIDeep(string dependence, string label, int id, string key)
    {
        sDeepLevel++;

        int selectedLine = 0;

        XlsxDataUnit unit = XlsxDataManager.Instance().GetXlsxByName(dependence);


        string[] optionList = unit.GetKeyNameList();

        selectedLine = unit.GetLineByID(id);

        EditorGUILayout.BeginHorizontal();
        {
            mDicToggleDic[key] = EditorGUILayout.Foldout(mDicToggleDic[key], label);
            selectedLine = EditorGUILayout.Popup("", selectedLine, optionList);
            //selectedLine = m_pDicSelectDic[key];
        }
        EditorGUILayout.EndHorizontal();

        if (mDicSelectDic[key] != selectedLine)
        {
            mDicSelectDic[key] = selectedLine;
        }

        if (mDicToggleDic[key])
        {
            // get the index of line
            if (selectedLine >= 0)
            {
                XlsxDataManager.Instance().SetDirty(dependence);
                // dfs, need get the loop path, prevent the StackOverFollow
                unit.OnGUIUpdate(selectedLine);
            }
        }

        sDeepLevel--;

        if (selectedLine >= 0)
        {
            return unit.GetRowDataByLine(selectedLine + XLS_DATA_INDEX)["ID"].CustomIDToInt(mCurIDType);
            //return Convert.ToInt32(value);
        }
        else
        {
            return id;
        }

    }

    private string _onGUIBool(string value, string label)
    {
        bool bValue = value != "0";

        bValue = EditorGUILayout.Toggle(label, bValue);
        // TODO there may add some comments append the option

        return bValue ? "1" : "0";
    }

    private int _onGUIEnum(int value, string label, int idx)
    {
        EditorGUILayout.BeginHorizontal();
        {
            string eType = "e" + mDictProtoKeyKV[idx].Key;
            Assembly ass = Assembly.GetAssembly(typeof(Utility));
            object classObj = ass.CreateInstance(ProtoClassName);
            Type emType = classObj.GetType().GetNestedType(eType);

            value = Convert.ToInt32(EditorGUILayout.EnumPopup(label, Enum.ToObject(emType, value) as Enum));

            string comment = "";
            foreach (var item in mDictHeadKV[idx].Value)
            {
                if (item.value == value)
                {
                    comment = item.comment;
                }
            }

            EditorGUILayout.LabelField(comment);
        }
        EditorGUILayout.EndHorizontal();

        return value;
    }

    private string _onGUIInt(string value, string label)
    {
        EditorGUILayout.BeginHorizontal();
        {
            try
            {
                value = EditorGUILayout.IntField(label, int.Parse(value)).ToString();
            }
            catch (Exception)
            {
                value = EditorGUILayout.IntField(label, 0).ToString();
            }
        }
        EditorGUILayout.EndHorizontal();
        return value;
    }

    public void OnGUIUpdate(int index)
    {

        var recDic = GetRowDataByLine(index + XLS_DATA_INDEX);

        EditorGUILayout.BeginVertical("ObjectFieldThumb");
        {
            EditorGUILayout.Space();
            EditorGUI.indentLevel += 1;

            if (recDic != null)
            {
                for (int i = 1; i < mCellCount; i++)
                {
                    string key = mDictHeadKV[i].Key;
                    string curType = mDictProtoTypeKV[i].Key;
                    string curTypeDependence = mDictProtoTypeKV[i].Value;
                    string curMod = mDictProtoModKV[i].Key;

                    string levelKey = string.Format("{0}_{1}", key, sDeepLevel);

                    ICell curDataCell = null;

                    if (recDic.ContainsKey(key))
                    {
                        curDataCell = recDic[key];
                    }
                    else
                    {
                        continue;
                    }

                    if (!mDicToggleDic.ContainsKey(levelKey))
                    {
                        mDicToggleDic.Add(levelKey, false);
                        mDicSelectDic.Add(levelKey, -1);
                    }

                    if (curMod == "repeated")
                    {
                        string[] curSplit = curDataCell.ToString().Split(SPLITE_REPEATED);
                        int curSplitLen = curSplit.Length;

                        EditorGUILayout.BeginHorizontal("ObjectFieldThumb");
                        {
                            if (!mDicToggleCount.ContainsKey(levelKey))
                            {
                                mDicToggleCount.Add(levelKey, curSplitLen);
                                mDicMask.Add(levelKey, 0);
                            }

                            mDicToggleDic[levelKey] = EditorGUILayout.Foldout(mDicToggleDic[levelKey], key);

                            {
                                mDicToggleCount[levelKey] = EditorGUILayout.IntField("数组大小:", mDicToggleCount[levelKey]);

                                if (mDicToggleCount[levelKey] < 1)
                                {
                                    mDicToggleCount[levelKey] = 1;
                                }
                                else if (mDicToggleCount[levelKey] > 20)
                                {
                                    mDicToggleCount[levelKey] = 20;
                                }
                                curDataCell.SetCellValue(EditorGUILayout.TextArea(curDataCell.ToString()));
                            }
                        }
                        EditorGUILayout.EndHorizontal();

                        {
                            EditorGUILayout.Space();

                            string newCellStr = "";
                            if (mDicToggleCount[levelKey] > curSplitLen) // inc count
                            {
                                newCellStr = curDataCell.ToString();
                                for (int j = curSplitLen; j < mDicToggleCount[levelKey]; j++)
                                {
                                    newCellStr += string.Format("{0}0", SPLITE_REPEATED);
                                }
                            }
                            else if (mDicToggleCount[levelKey] < curSplitLen) // desc count
                            {
                                newCellStr = curSplit[0];
                                for (int j = 1; j < mDicToggleCount[levelKey]; j++)
                                {
                                    newCellStr += string.Format("{0}{1}", SPLITE_REPEATED, curSplit[j]);
                                }
                            }

                            if (mDicToggleCount[levelKey] != curSplitLen)
                            {
                                curDataCell.SetCellValue(newCellStr);
                                curSplit = newCellStr.Split(SPLITE_REPEATED);
                                mDicToggleCount[levelKey] = curSplit.Length;
                            }

                            EditorGUI.indentLevel += 1;
                            if (mDicToggleDic[levelKey])
                            {
                                for (int idx = 0; idx < curSplit.Length; idx++)
                                {
                                    if (curType == "sint32" || curType == "enum")
                                    {
                                        //bool idxFlode = false;
                                        string idxKey = string.Format("{0}_{1}_{2}", levelKey, idx, sDeepLevel);

                                        if (!mDicToggleDic.ContainsKey(idxKey))
                                        {
                                            mDicToggleDic.Add(idxKey, false);
                                            mDicSelectDic.Add(idxKey, -1);
                                        }

                                        int tmpid = 0;

                                        try
                                        {
                                            tmpid = Convert.ToInt32(curSplit[idx]);
                                        }
                                        catch (Exception)
                                        {

                                        }

                                        if (curTypeDependence.Length > 0)
                                        {

                                            curSplit[idx] = _onGUIDeep(curTypeDependence, "", tmpid, idxKey).ToString();
                                        }
                                        else if (curType == "sint32")
                                        {
                                            curSplit[idx] = _onGUIInt(curSplit[idx], "").ToString();
                                        }
                                        else if (curType == "enum")
                                        {
                                            curSplit[idx] = _onGUIEnum(tmpid, "", i).ToString();
                                        }
                                    }
                                    else if (curType == "string")
                                    {
                                        curSplit[idx] = EditorGUILayout.TextField(_getLabelName(idx.ToString(), curType), curSplit[idx].ToString());
                                    }
                                }
                                curDataCell.SetCellValue(string.Join(string.Format("{0}", SPLITE_REPEATED), curSplit));
                            }
                            EditorGUI.indentLevel -= 1;
                        }
                    }
                    else if (curType == "sint32") // not repeated
                    {
                        if (curTypeDependence.Length > 0)
                        {
                            curDataCell.SetCellValue(_onGUIDeep(curTypeDependence, key, Convert.ToInt32(curDataCell.ToString()), levelKey).ToString());
                        }
                        else
                        {
                            curDataCell.SetCellValue(Convert.ToInt32(_onGUIInt(curDataCell.ToString(), _getLabelName(key, curType))));
                        }
                    }
                    else if (curType == "bool")
                    {
                        curDataCell.SetCellValue(_onGUIBool(curDataCell.ToString(), _getLabelName(key, curType)));
                    }
                    else if (curType == "enum")
                    {
                        int value = Convert.ToInt32(curDataCell.ToString());
                        curDataCell.SetCellValue(_onGUIEnum(value, _getLabelName(key, curType), i));
                    }
                    else
                    {
                        curDataCell.SetCellValue(EditorGUILayout.TextField(_getLabelName(key, curType), curDataCell.ToString()));
                    }
                }
            }
        }
        EditorGUILayout.EndVertical();

    }
#endregion

#region Editor Tool
    //private int mEditorPopupSelectItem = -1;
    public delegate bool PopupFilter(int id);
    private List<KeyValuePair<int, string>> _getFilerKeyNameList(PopupFilter filter)
    {
        List<KeyValuePair<int, string>> knList = new List<KeyValuePair<int, string>>();

        for (int i = XLS_DATA_INDEX; i < mRowCount; i++)
        {
            IRow curRow = mCurSheet.GetRow(i);
            ICell idCell = curRow.GetCell(0);
            ICell sndCell = curRow.GetCell(1);
            if (_isValidRow(curRow, i))
            {
                var keyv = new KeyValuePair<int, string>(idCell.CustomToInt(), sndCell.CustomToString());
                if (filter != null)
                {
                    if (filter(idCell.CustomIDToInt()))
                    {
                        knList.Add(keyv);
                    }
                }
                else
                {
                    knList.Add(keyv);
                }
            }
        }

        return knList;
    }

    private int _findSelectIndexByID(List<KeyValuePair<int, string>> keynamelist, int id)
    {
        for (int i = 0; i < keynamelist.Count; ++i)
        {
            if (keynamelist[i].Key == id)
            {
                return i;
            }
        }

        return -1;
    }

    private string[] _convertKeyValueList2String(List<KeyValuePair<int, string>> keynamelist)
    {
        string[] array = new string[keynamelist.Count];
        for (int i = 0; i < keynamelist.Count; i++)
        {
            var item = keynamelist[i];
            array[i] = string.Format("{0}({1})", item.Key, item.Value);
        }
        return array;
    }

    public bool EditorPopup(string name, ref int id, PopupFilter filter = null)
    {
        bool resulte = false;

        var keynamelist = _getFilerKeyNameList(filter);
        var oselect = _findSelectIndexByID(keynamelist, id);
        int nselect = EditorGUILayout.Popup(name, oselect, _convertKeyValueList2String(keynamelist));

        if (nselect != oselect)
        {
            oselect = nselect;
            id = keynamelist[nselect].Key;
            resulte = true;
        }

        return resulte;
    } 

    public void MergeXls(XlsxDataUnit otherUnit)
    {
        int count = 0;
        for(int i=0; i<otherUnit.RowCount; ++i)
        {
            var kvData = otherUnit.GetRowDataByLine(i);
            if (kvData == null)
                continue;
            
            int ikey = kvData["ID"].CustomIDToInt();

            if (!mDictData.ContainsKey(ikey))
            {
                mDictData.Add(ikey, kvData);
                mDictDataByLine.Add(RowCount + count, kvData);
               // Logger.LogErrorFormat("mDictDataByLine add {0} key:{1}", RowCount + count, ikey);
                mDictID2Line.Add(ikey, RowCount + i - XLS_DATA_INDEX);

                count++;
            }
        }

        RowCount += count;
    }
#endregion

    public static string[] GetXLSFileList()
    {
        string[] strList = Directory.GetFiles(DataUnitPath.XLS_PATH, "*.xls", SearchOption.AllDirectories);

        for (int i = 0; i < strList.Length; i++)
        {
            strList[i] = strList[i].Replace('\\', '/');
        }

        XlsxDebug.Log(string.Join("\n", strList));

        return strList;
    }

    public static void WriteTableGenerateProtoClassText(string[] fileList)
    {
        if (fileList != null)
        {
            foreach (string item in fileList)
            {
                XlsxDataUnit unit = new XlsxDataUnit(item);
                unit.GetText();
            }
        }
        else
        {
            XlsxDebug.Log("[WriteTableGenerateProtoClass] : Empty the WriteTableGenerateProtoClass.cs");
        }
    }


    public static void WriteTableGenerateProtoClassServerText(string[] fileList)
    {
        if (fileList != null)
        {
            foreach (string item in fileList)
            {
                XlsxDataUnit unit = new XlsxDataUnit(item);
                unit.GetServerText();
            }
        }
        else
        {
            XlsxDebug.Log("[WriteTableGenerateProtoClass] : Empty the WriteTableGenerateProtoClass.cs");
        }
    }

    public static void WriteTableGenerateProtoClassCode(string[] fileList)
    {
        if (fileList != null)
        {
            foreach (string item in fileList)
            {
                XlsxDataUnit unit = new XlsxDataUnit(item);
                if (unit.GetProto())
                {
                    unit.GetCSCode();
                }
            }
        }
        else
        {
            XlsxDebug.Log("[WriteTableGenerateProtoClass] : Empty the WriteTableGenerateProtoClass.cs");
        }
    }

    public static void WriteTableGenerateProtoClass(string[] fileList, bool bOnlyText = false)
    {
        if (fileList != null)
        {
            foreach (string item in fileList)
            {
                XlsxDataUnit unit = new XlsxDataUnit(item);
                if (!bOnlyText)
                {
                    if (unit.GetProto())
                    {
                        unit.GetCSCode();
                    }
                }
                unit.GetText();
            }
        }
        else
        {
            XlsxDebug.Log("[WriteTableGenerateProtoClass] : Empty the WriteTableGenerateProtoClass.cs");
        }
    }
    public static void GenerateProtoCS(string[] fileList, bool bOnlyText = false)
    {
        if (fileList != null)
        {
            if (!bOnlyText)
            {

                foreach (string item in fileList)
                {
                    try
                    {
                        XlsxDataUnit unit = new XlsxDataUnit(item);
                        unit.GetProto();
                        unit.GetCSCode();
                    }
                    catch (Exception e)
                    {
                        XlsxDebug.LogErrorFormat("[GenerateProtoCS] : {0}, {1} ", item, e.ToString());
                    }
                }
            }
        }
        else
        {
            XlsxDebug.Log("[GenerateProtoCS] : Empty the WriteTableGenerateProtoClass.cs");
        }
    }

    public struct XlsFileSplitMap
    {
        public string mainName;
        public string[] splitFileNames;

        public XlsFileSplitMap(string name, string[] splits)
        {
            mainName = name;
            splitFileNames = splits;
        }
    }

    public static XlsFileSplitMap[] splitXls =
    {
        new XlsFileSplitMap("C-触发效果表.xls", new string[]{"C-触发效果表_怪物.xls"}),
        new XlsFileSplitMap("J-技能表.xls", new string[]{"J-技能表_怪物.xls", "J-技能表_被动.xls", "J-技能表_宠物.xls"}),
        new XlsFileSplitMap("G-怪物表.xls", new string[]{ "G-怪物表_关卡.xls", "G-怪物表_活动.xls", "G-怪物表_技能.xls"}),
        new XlsFileSplitMap("D-道具表.xls", new string[]{ "D-道具表_时装.xls", "D-道具表_装备.xls", "D-道具表_强化券.xls"}),
        new XlsFileSplitMap("B-被动技能机制表.xls", new string[]{ "B-被动技能机制表_装备.xls"}),
    };
    public static bool NeedIgnore(string name)
    {
        var tokens = name.Split('/');
        if (tokens.Length == 1)
            tokens = name.Split('\\');

        var fileName = tokens[tokens.Length - 1];

        for (int i = 0; i < splitXls.Length; ++i)
        {
            for(int j=0; j< splitXls[i].splitFileNames.Length; ++j)
            {
                if (splitXls[i].splitFileNames[j].Contains(fileName))
                    return true;
            }
        }

        return false;
    }

    public static void MergeTablesNew(string name, XlsxDataUnit unit, System.Diagnostics.Stopwatch watch)
    {
        var startTime = watch.ElapsedMilliseconds;

        var tokens = name.Split('/');
        var fileName = tokens[tokens.Length - 1];

           for (int i = 0; i < splitXls.Length; ++i)
            if (splitXls[i].mainName.Contains(fileName))
            {
                for(int j=0; j< splitXls[i].splitFileNames.Length; ++j)
                {
                     var itemSplit = name.Replace(splitXls[i].mainName, splitXls[i].splitFileNames[j]);
                     XlsxDataUnit unitSplit = new XlsxDataUnit(itemSplit);
                     unit.mergedSheets.Add(unitSplit);

                    //Logger.LogErrorFormat("step合表2 unit 经过time:{0} 总时间:{1}", watch.ElapsedMilliseconds-startTime, watch.ElapsedMilliseconds);
                    startTime = watch.ElapsedMilliseconds;
                }
            }

    }

    public static void MergeTables(string name, XlsxDataUnit unit)
    {
        var tokens = name.Split('/');
        var fileName = tokens[tokens.Length - 1];

        //Logger.LogErrorFormat("unit row count:{0} item:{1}", unit.RowCount, fileName);

        for (int i = 0; i < splitXls.Length; ++i)
            if (splitXls[i].mainName.Contains(fileName))
            {
                for(int j=0; j< splitXls[i].splitFileNames.Length; ++j)
                {
                    var itemSplit = name.Replace(splitXls[i].mainName, splitXls[i].splitFileNames[j]);
                    XlsxDataUnit unitSplit = new XlsxDataUnit(itemSplit);

                    //Logger.LogErrorFormat("other unit row count:{0} item:{1}", unitSplit.RowCount, itemSplit);

                    unit.MergeXls(unitSplit);
                }
                
                break;
            }

        //Logger.LogErrorFormat("after merget row count:{0}", unit.RowCount);

    }

    

    public static void GenerateText(string[] fileList, bool bOnlyText = false)
    {
        if (fileList != null)
        {
            foreach (string item in fileList)
            {
                try
                {
                    XlsxDataUnit unit = new XlsxDataUnit(item);
					if (Xls2FBWindow.UseSplitTable())
                    {
                        if (NeedIgnore(item))
                        {
                            continue;
                        }

                        MergeTables(item, unit);
                    }
                    
                    unit.GetText();
                }
                catch (Exception e)
                {
                    XlsxDebug.LogErrorFormat("[GenerateText] : 保证CS文件和Xlsx匹配{0}, {1} ", item, e.ToString());
                }
            }
        }
        else
        {
            XlsxDebug.Log("[GenerateText] : Empty the WriteTableGenerateProtoClass.cs");
        }
    }

    public static void XLS2TXT()
    {
        string[] fileList = GetXLSFileList();
        WriteTableGenerateProtoClass(fileList);
    }

    public static void XLS2CODE()
    {
        string[] fileList = GetXLSFileList();
        WriteTableGenerateProtoClassCode(fileList);
    }

    public static void XLS2TEXT()
    {
        string[] fileList = GetXLSFileList();
        WriteTableGenerateProtoClassText(fileList);
    }


    public static void TestWrite()
    {
        XlsxDataUnit unit = new XlsxDataUnit("../../Documents/全局文档/表格/触发效果表.xls");
        Dictionary<string, ICell> reDic = null;

        reDic = unit.GetRowData(1);
        reDic = unit.GetRowData(1000);
        XlsxDebug.Log(reDic["伤害属性"].StringCellValue.ToString());

        reDic["伤害属性"].SetCellValue("ss");
        XlsxDebug.Log(reDic["伤害属性"].StringCellValue.ToString());

        unit.Write();
    }
}

public class TextDataStream : FileStream
{
    private const int HEAD_LEN = 8;

    private long m_iStartPos = 0;
    private long m_iEndPos = 0;

    private byte[] m_pLenBuff = new byte[8];

    public TextDataStream(string textPath)
        : base(textPath, FileMode.CreateNew, FileAccess.Write)
    {
    }

    public void Write<T>(T unit) where T : new()
    {
        m_iStartPos = Position;
        Write(m_pLenBuff, 0, HEAD_LEN);
        //Serializer.Serialize<T>(this as Stream, unit);

        m_iEndPos = Position;

        long le = m_iEndPos - m_iStartPos - HEAD_LEN;
        char[] strbyte = le.ToString().ToCharArray();

        for (int jj = 0; jj < HEAD_LEN; jj++)
        {
            if (jj < strbyte.Length)
            {
                m_pLenBuff[jj] = (byte)strbyte[jj];
            }
            else
            {
                m_pLenBuff[jj] = 0;
            }
        }

        Seek(m_iStartPos, SeekOrigin.Begin);
        Write(m_pLenBuff, 0, HEAD_LEN);
        Seek(0, SeekOrigin.End);
    }

    public void Write(object unit)
    {
        m_iStartPos = Position;
        Write(m_pLenBuff, 0, HEAD_LEN);
        //RuntimeTypeModel.Default.Serialize(this as Stream, unit);

        m_iEndPos = Position;

        long le = m_iEndPos - m_iStartPos - HEAD_LEN;
        char[] strbyte = le.ToString().ToCharArray();

        for (int jj = 0; jj < HEAD_LEN; jj++)
        {
            if (jj < strbyte.Length)
            {
                m_pLenBuff[jj] = (byte)strbyte[jj];
            }
            else
            {
                m_pLenBuff[jj] = 0;
            }
        }

        Seek(m_iStartPos, SeekOrigin.Begin);
        Write(m_pLenBuff, 0, HEAD_LEN);
        Seek(0, SeekOrigin.End);
    }

}

public class XlsxDataManager
{
    // key: sheetname  value : XlsxDataUnit
    private static Dictionary<string, XlsxDataUnit> m_pDictUnit = new Dictionary<string, XlsxDataUnit>();
    private static Dictionary<string, XlsxDataUnit> m_pDictUnitCache = new Dictionary<string, XlsxDataUnit>();
    private static Dictionary<string, string[]> m_pDictUnitMap = new Dictionary<string, string[]>();
    // key: sheetname  value : last modify time
    private static Dictionary<string, DateTime> m_pDictLastDateTime = new Dictionary<string, DateTime>();

    // dirty map
    private static Dictionary<string, bool> m_pDictUnitDirtyMap = new Dictionary<string, bool>();

    private static XlsxDataManager m_pInstance = null;
    public static string[] GetXLSFileList()
    {
        List<string> finalList = new List<string>();
        string[] strList = Directory.GetFiles(DataUnitPath.XLS_PATH, "*.xls", SearchOption.AllDirectories);

        for (int i = 0; i < strList.Length; i++)
        {
            strList[i] = strList[i].Replace('\\', '/');
            if (strList[i].EndsWith("xls"))
            {
                if (Xls2FBWindow.UseSplitTable())
                {
                    if (XlsxDataUnit.NeedIgnore(strList[i]))
                    {
                        continue;
                    }
                }

                finalList.Add(strList[i]);
            }
        }
        strList = finalList.ToArray();
        XlsxDebug.Log(string.Join("\n", strList));

        return strList;
    }

    private static List<string> m_pListMainEnterPoint = new List<string>();

    public static XlsxDataManager Instance()
    {
        if (m_pInstance == null)
        {
            m_pInstance = new XlsxDataManager();
        }

        return m_pInstance;
    }

    public XlsxDataManager()
    {
        LoadAllXls();
    }

    public static Dictionary<string, string> m_pDictKeyPath = new Dictionary<string, string>();

    public void SetDirty(string name)
    {
        if (!m_pDictUnitDirtyMap.ContainsKey(name))
        {
            m_pDictUnitDirtyMap.Add(name, false);
        }

        m_pDictUnitDirtyMap[name] = true;
    }

    private void LoadAllXls()
    {
        string[] fileList = GetXLSFileList();

        m_pDictUnit.Clear();
        m_pDictUnitCache.Clear();
        m_pDictUnitMap.Clear();
        m_pDictKeyPath.Clear();
        m_pDictLastDateTime.Clear();

        //var dataTem = Directory.GetLastAccessTime("").;
        //Directory.GetLastWriteTime("");

        foreach (string path in fileList)
        {
            AddXlsx(path);
        }
    }

    public void AddXlsx(string path)
    {
        XlsxDataUnit unit = new XlsxDataUnit(path);
        if (!unit.IsValid)
        {
            //if (EditorUtility.DisplayDialog("数据表出错", path + "\n" + unit.ErrorMessage, "确定"))
            {
                XlsxDebug.LogErrorFormat("[AddXlsx] : 数据表 {0} 格式错误", path);
            }

            return;
        }
        // add the the sheetname -> unit
        if (!m_pDictUnit.ContainsKey(unit.ProtoName))
        {
            m_pDictUnit.Add(unit.ProtoName, unit);
        }
        else
        {
            m_pDictUnit[unit.ProtoName] = unit;
        }

        // the cache
        if (!m_pDictUnitCache.ContainsKey(unit.ProtoName))
        {
            m_pDictUnitCache.Add(unit.ProtoName, unit.Clone() as XlsxDataUnit);
        }
        else
        {
            m_pDictUnitCache[unit.ProtoName] = unit.Clone() as XlsxDataUnit;
        }

        // the last modify datetime
        if (!m_pDictLastDateTime.ContainsKey(unit.ProtoName))
        {
            m_pDictLastDateTime.Add(unit.ProtoName, unit.LastWriteTime);
        }
        else
        {
            m_pDictLastDateTime[unit.ProtoName] = unit.LastWriteTime;
        }

        // build the map
        if (!m_pDictUnitMap.ContainsKey(unit.ProtoName))
        {
            m_pDictUnitMap.Add(unit.ProtoName, unit.GetDependents());
        }
        else
        {
            m_pDictUnitMap[unit.ProtoName] = unit.GetDependents();
        }

        if (!m_pDictKeyPath.ContainsKey(unit.ProtoName))
        {
            m_pDictKeyPath.Add(unit.ProtoName, path);
        }
        else
        {
            m_pDictKeyPath[unit.ProtoName] = path;
        }
    }

    public string[] GetAllTableName()
    {
        string[] tables = new string[m_pDictUnitCache.Count];
        Dictionary<string, XlsxDataUnit>.Enumerator it = m_pDictUnitCache.GetEnumerator();
        int count = 0;
        while (it.MoveNext())
        {
            var cur = it.Current;
            tables[count++] = cur.Key;
        }
        return tables;
    }
    public XlsxDataUnit GetXlsxByName(string name)
    {
        if (!m_pDictUnitCache.ContainsKey(name))
        {
            //XlsxDebug.LogErrorFormat("Not Found : {0}", name);
            return null;
        }

        var unit = m_pDictUnitCache[name];
        var datatime = unit.LastWriteTime;

        if (!m_pDictLastDateTime.ContainsKey(name))
        {
            m_pDictLastDateTime.Add(name, datatime);
            Reload(name);
        }
        else if (!datatime.Equals(m_pDictLastDateTime[name]))
        {
            Reload(name);
            m_pDictLastDateTime[name] = datatime;
        }

        return m_pDictUnitCache[name];
    }

    public bool IsContainLoop(string workbookName)
    {
        return false;
    }

    public void Write(string key)
    {
        // write the cache to the file
        if (m_pDictUnitCache[key].Write())
        {
            m_pDictUnitCache[key].Close();
            m_pDictUnitCache.Remove(key);

            // close the origin workbook
            m_pDictUnit[key].Close();
            m_pDictUnit.Remove(key);

            AddXlsx(m_pDictKeyPath[key]);
        }
    }

    public void WriteAllDirty()
    {
        foreach (var key in m_pDictUnitDirtyMap.Keys)
        {
            Write(key);
            // BUILD THE XLSX to TXT
            XlsxDataUnit.WriteTableGenerateProtoClass(new string[] { m_pDictKeyPath[key] }, true);
        }

        m_pDictUnitDirtyMap.Clear();
    }

    private static Dictionary<string, bool> m_pDictMainEnterFlode = new Dictionary<string, bool>();
    private static Dictionary<string, Vector2> m_pDictMainEnterVec = new Dictionary<string, Vector2>();
    private static Dictionary<string, int> m_pDictMainEnterSelect = new Dictionary<string, int>();
    private static Dictionary<string, string[]> m_pDictMainEnterOptionList = new Dictionary<string, string[]>();

    public void Reload(string key)
    {
        // TOOD reload the key, may relaod
        if (m_pDictUnitCache.ContainsKey(key))
        {
            //m_pDictUnitCache[key] = null;
            m_pDictUnitCache[key] = m_pDictUnit[key].Clone() as XlsxDataUnit;
        }
        else
        {
            m_pDictUnitCache.Add(key, m_pDictUnit[key].Clone() as XlsxDataUnit);
        }
    }

    public void GetAllPath()
    {

    }

    public void AddMainEnterPoint(string name)
    {
        if (m_pDictUnitCache.ContainsKey(name))
        {
            XlsxDataUnit unit = m_pDictUnitCache[name];
            if (unit.IsValid)
            {
                if (!m_pListMainEnterPoint.Contains(name))
                {
                    m_pListMainEnterPoint.Add(name);
                }
                if (!m_pDictMainEnterOptionList.ContainsKey(name))
                {
                    m_pDictMainEnterOptionList.Add(name, unit.GetKeyNameList());
                }
                if (!m_pDictMainEnterSelect.ContainsKey(name))
                {
                    m_pDictMainEnterSelect.Add(name, -1);
                }
                if (!m_pDictMainEnterVec.ContainsKey(name))
                {
                    m_pDictMainEnterVec.Add(name, new Vector2());
                }
            }
        }

        if (!m_pDictMainEnterFlode.ContainsKey(name))
        {
            m_pDictMainEnterFlode.Add(name, false);
        }
    }


    public void OnGUIUpdate(string key, string lableName, int index)
    {
        {
            bool bFlode = m_pDictMainEnterFlode[key];

            EditorGUILayout.BeginHorizontal();
            {
                bFlode = EditorGUILayout.Foldout(bFlode, lableName, "Foldout");
                m_pDictMainEnterFlode[key] = bFlode;

                XlsxDataUnit.sDebug = EditorGUILayout.Toggle("DebugInfo", XlsxDataUnit.sDebug);
            }
            EditorGUILayout.EndHorizontal();

            if (m_pDictUnitCache.ContainsKey(key))
            {
                string[] pSelectOptions = m_pDictMainEnterOptionList[key];

                if (bFlode)
                {
                    if (m_pDictMainEnterSelect[key] != index)
                    {
                        m_pDictMainEnterSelect[key] = index;
                        Reload(key);
                    }
                    else
                    {
                        // TODO UPDATE
                        XlsxDataUnit xlsxDataUnit = m_pDictUnitCache[key];

                        SetDirty(key);

                        int iSelect = xlsxDataUnit.GetLineByID(m_pDictMainEnterSelect[key]);
                        if (xlsxDataUnit.IsValid && iSelect >= 0)
                        {
                            xlsxDataUnit.OnGUIUpdate(iSelect);

                            EditorGUILayout.BeginHorizontal();
                            if (StyledButton("重新加载"))
                            {
                                Reload(key);

                                m_pDictUnitDirtyMap.Clear();
                                SetDirty(key);
                            }

                            if (StyledButton("保存"))
                            {
                                WriteAllDirty();

                                SetDirty(key);
                            }
                            EditorGUILayout.EndHorizontal();
                        }
                        else
                        {
                            EditorGUILayout.LabelField(string.Format("表中没有相应ID字段: {0}", m_pDictMainEnterSelect[key]));
                            EditorGUI.indentLevel++;
                            EditorGUILayout.BeginHorizontal("ObjectFieldThumb");
                            {
                                m_pDictMainEnterVec[key] = EditorGUILayout.BeginScrollView(m_pDictMainEnterVec[key], GUILayout.Height(200));
                                {
                                    foreach (var item in pSelectOptions)
                                    {
                                        EditorGUILayout.LabelField(item);
                                    }
                                }
                                EditorGUILayout.EndScrollView();
                            }
                            EditorGUILayout.EndHorizontal();
                            EditorGUI.indentLevel--;
                        }
                    }
                }
            }
            else
            {
                m_pDictMainEnterFlode[key] = true;
                EditorGUILayout.LabelField("表格出现错误");
            }
        }
    }

    public static bool StyledButton(string label)
    {
        EditorGUILayout.Space();
        GUILayoutUtility.GetRect(1, 20);
        EditorGUILayout.BeginHorizontal();
        GUILayout.FlexibleSpace();
        bool clickResult = GUILayout.Button(label, "miniButton");
        GUILayout.FlexibleSpace();
        EditorGUILayout.EndHorizontal();
        EditorGUILayout.Space();
        return clickResult;
    }
}
